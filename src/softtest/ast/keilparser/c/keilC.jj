/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. keilC.jj */
/*@egen*//*

  C grammar defintion for use with JavaCC
  Contributed by Doug South (dsouth@squirrel.com.au) 21/3/97

  This parser assumes that the C source file has been preprocessed : all
  #includes have been included and all macros have been expanded. I accomplish
  this with "gcc -P -E <source file> > <output file>".

  There is a problem with compiler specific types, such as __signed, __const,
  __inline__, etc. These types can be added as typedef types before the parser
  is run on a file. See main() for an example. I have also found a strange little
  compiler specific "type" if you can call it that. It is __attribute__, but it
  does not seem to be used as a type. I found that just deleting the __attribute__
  and the following "offensive" code works.

  This grammar also prints out all the types defined while parsing the file. This
  is done via a call to printTypes() when the parser is complete. If you do not want
  this, just comment out the printTypes() method call in the production rule
  TranslationUnit(), which BTW is the root node for parsing a C source file.

  I have not in anyway extensively tested this grammar, in fact it is barely tested,
  but I imagine it is better to have a starting point for a C grammar other than from
  scratch. It has not been optimized in anyway, my main aim was to get a parser that
  works. Lookahead may not be optimum at choice points and may even be insufficient at
  times. I choose to err on the side of not optimum if I made a choice at all.

  If you use this grammar, I would appreciate hearing from you. I will try to maintain
  this grammar to the best of my ability, but at this point in time, this is only a side
  hobby (unless someone wants to pay me for doing JavaCC work!). In that regards, I am
  interested in hearing bugs and comments.

  TODO:
    Insert the appropriate code to enable C source trees from this grammar.

=============================================
3/2/06: Modified by Tom Copeland
- STRING_LITERAL now handles embedded escaped newlines, thanks to J.Chris Findlay for the patch
- Works with JavaCC 4.0
- Preprocessor directives are now simply SKIP'd, so no need to run C files through GCC first

  */
options {
  BUILD_PARSER=true;
  JAVA_UNICODE_ESCAPE = true;
  CACHE_TOKENS = true;
  STATIC = false;
  USER_CHAR_STREAM = true;
  
               
                 
  
                       
  
                          
  OUTPUT_DIRECTORY = "keil";
  
                                
}

PARSER_BEGIN(CParser)
package softtest.ast.c;

import java.util.*;
import java.io.*;

import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.apache.log4j.Logger;
import org.w3c.dom.Document;

  public class CParser/*@bgen(jjtree)*/implements CParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTCParserState jjtree = new JJTCParserState();

/*@egen*/
        private ArrayList errorMsg = new ArrayList();

        public boolean isError() {
                return  errorMsg.size() != 0;
        }

        public ArrayList getErrorMsg() {
                return errorMsg;
        }

    // Hastable for storing typedef types
    private Set types = new HashSet();

    // Stack for determining when the parser
    // is parsing a typdef definition.
    private Stack typedefParsingStack = new Stack();
        public void pushTypedefParsingStack(Object o,String reason){
                typedefParsingStack.push(o);
                //System.out.println("Push in:"+o+" "+reason+" in Line:"+jj_nt.beginLine+" size:"+typedefParsingStack.size());
        }
        public void popTypedefParsingStack(String reason){
                Object o=typedefParsingStack.pop();
                //System.out.println("Pop out:"+o+" "+reason+" in Line:"+jj_nt.beginLine+" size:"+typedefParsingStack.size()); 
        }
        private Stack structStack = new Stack();

		private Logger logger = Logger.getLogger(CParser.class);

    // Returns true if the given string is
    // a typedef type.
    private boolean isType(String type){
          return types.contains(type);
    }

    // Add a typedef type to those already defined
    private void addType(String type){
          types.add(type);
    }

    // Prints out all the types used in parsing the c source
    private void printTypes(){
      String[] strs= new String[types.size()];
      int j=0;
      for (Iterator i = types.iterator(); i.hasNext();) {
          strs[j++]=(String)(i.next());
      }
      Arrays.sort(strs);
      for (int i=0;i<strs.length;i++){
          System.out.println(strs[i]);
      }
    }

        public static ASTTranslationUnit createAST(java.io.StringReader input) {
                try {

                                CCharStream ccs = new CCharStream(input);
                                CParser parser = new CParser(ccs);

                                ASTTranslationUnit astcu = parser.TranslationUnit();
                                System.out.println("parsed successfully :) ");
                                                return astcu;




                                } catch (ParseException pe) {
                                        pe.printStackTrace();
                                                        return null;
                                                }
           }

   public static ASTTranslationUnit parser(String inputfile){
                  CParser parser = null;
                  ASTTranslationUnit astroot = null;
                try {
                        parser = new CParser(new CCharStream(new FileInputStream(inputfile)));
                } catch (FileNotFoundException e) {
                        // TODO Auto-generated catch bloc

                        e.printStackTrace();
                }

                try {
                        astroot = parser.TranslationUnit();
                } catch (ParseException e) {

                        e.printStackTrace();

                }
                  return astroot;
          }

    // Run the parser
    public static void main(String args[]) {/*
	   CParser parser;
       java.io.InputStream input;
         String pre="<";    //\u7528\u6765\u505a\u8bed\u6cd5\u6811\u8f93\u51fa\u7684\u6807\u7b7e
         System.out.println("Reading from C file  . . .");
         try {
           input = new java.io.FileInputStream(new java.io.File("d:/ctest.c"));
           CCharStream cs = new CCharStream(input);
           parser = new CParser(cs);

           ASTTranslationUnit astcu = parser.TranslationUnit();
           
           Document document = astcu.asXml();
           TransformerFactory tFactory = TransformerFactory.newInstance();
           Transformer transformer;
			transformer = tFactory.newTransformer();
           DOMSource source = new DOMSource(document);
           StreamResult streamResult = new StreamResult(new File("e:\\Welcome_document.c.xml"));
			transformer.transform(source, streamResult);


           System.out.println("Parser ending");
           astcu.dump(pre);   //\u5c06\u8bed\u6cd5\u6811\u8f93\u51fa\u5230buffer\u4e2d	        

           FileWriter fw = new FileWriter(new File("d:/ctree1.xml"));
           String strRes = new String(SimpleNode.buf);
           fw.write(strRes);
           fw.flush();

           System.out.println("parsed successfully :) ");
           } catch (java.io.FileNotFoundException e) {
               System.out.println("File  not found.");
           return;
         }
           catch (ParseException e) {
               e.printStackTrace();
               System.out.println("Encountered errors during parse.");
           } catch (IOException ioe)
           {
            ioe.printStackTrace();
           }
			catch (TransformerException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}*/

   }
   
   void error_skipto(int kind,Exception in_exception) throws  Exception{
   		throw in_exception;
   }

        void error_skipto1(int kind,Exception in_exception) {

        //logger.error(in_exception.toString());
        ParseException e = generateParseException();
        StackTraceElement st[] = e.getStackTrace();
        /*for (int i = 0; i < st.length; i++) {
                logger.error(st[i]);
                }
        */
        errorMsg.add(e.toString());



        Token t = getNextToken();
        t = getNextToken();
        int flag = 0;
        int bracketNum = 0, cbracketNum = 0;
        if (t.image.equals("(")) {
            flag = 1;
            bracketNum = 1;
        } else if (t.image.equals("{")) {
        	flag = 2;
        	cbracketNum = 1;
        }
        if (flag > 0) {
            while(bracketNum >= 0 ||cbracketNum >=0 ) {
            	t = getNextToken();
                if (t.image.equals("(")) {
                	bracketNum++;
                } else if (t.image.equals(")")) {
                	bracketNum--;
                } else if (t.image.equals("{")) {
                	cbracketNum++;
                } else if (t.image.equals("}")) {
                	cbracketNum--;
                }
                if (t.kind == CParserConstants.EOF || 
                	(cbracketNum <=0 &&(t.kind==CParserConstants.SEMICOLON || jj_nt.kind == CParserConstants.RIGHTCURLYBRACKETS))) {
                     return;
                }        
            }
        }

        do {
                t = getNextToken();
        } while (t.kind!=CParserConstants.EOF&&t.kind != kind);// The above loop consumes tokens all the way up to a token of

        // "kind".  We use a do-while loop rather than a while because the
        // current token is the one immediately before the erroneous token
        // (in our case the token immediately before what should have been
        // "if"/"while".
        }


	void DeclarationException(Exception ine)throws Exception{
		throw ine;
	}
	
   void DeclarationException1	(Exception ine){
        //logger.error(ine.toString());
        ParseException e = generateParseException();  // generate the exception object.
        StackTraceElement st[] = e.getStackTrace();
        /*for (int i = 0; i < st.length; i++) {
                        logger.error(st[i]);
        }*/
   }
   
}

PARSER_END(CParser)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
|  <"asm" (" "|"\t") ("\t"|"\n"|"\r"|" "|"\r\n")* "{" (~["{","}"])* "}">
|  <("__asm"|"__asm__") (" "|"\t") ("\t"|"\n"|"\r"|" "|"\r\n")* "{" (~["{","}"])* "}">
|  <"asm" (" "|"\t") (~["\n","\r","}","{","("])* ("\n" | "\r" | "\r\n")?>
|  <("__asm"|"__asm__") (" "|"\t") (~["\n","\r","}","{","("])* ("\n" | "\r" | "\r\n")?>
|  <("__asm"|"asm"|"__asm__") (" "|"\t"|"\n"|"\r")* "("> {
		int leftbracketnum=1;//\u5de6\u62ec\u53f7\u7684\u4e2a\u6570
		char c;
		try{
        	while(leftbracketnum>0&&(c=input_stream.readChar())>0){
      	   		if (c==')') leftbracketnum--;
            	if (c=='(') leftbracketnum++;
            }
            while((c=input_stream.readChar())>0){
            	if (c==';'){
         	     	break;
            	}
            	{
           			System.out.println("should be a <;> after __asm( <something> )");
            	}
            }
        }catch(Exception e){e.printStackTrace();}
    }
|  <"__attribute__((packed))">
|  <"__attribute__ ((__const__))">
|  <"__attribute__ ((__noreturn__))">
| "#" : PREPROCESSOR_OUTPUT
}

<PREPROCESSOR_OUTPUT> SKIP:
{
     "\n" : DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
 "\\\n"
 |
 "\\\r\n"
 |
 < ~[] >
}


TOKEN : {
// modify to support vc style integer 	
 <INTEGER_LITERAL: <DECIMAL_LITERAL> (((["u","U"])(["l","L"])?)?|((["l","L"])(["u","U"])?)|(("i64"|"LL"|"ll")?))
| <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>
|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
|  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+(((["u","U"])(["l","L"])?)?|((["l","L"])(["u","U"])?))>
|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
|  <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
|  <STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
}

//KEIL: Memory Areas Types
/*
TOKEN : {
	<CODE: "code">|		//program memory
	<DATA: "data">|		//internal data memory
	<IDATA: "idata">|
	<BDATA: "bdata">|
	<XDATA: "xdata">|	//external data memory
	<PDATA: "pdata">
	//<FAR: "far">		//ISO C has already had this keyword
}

//KEIL: Memory Models
TOKEN : {
	<SMALL: "small"> |
	<COMPACT: "compact"> |
	<LARGE: "large"> |
	
	// function declarations
	<REENTRANT: "reentrant"> |
	<INTERRUPT: "interrupt"> |
	<USING: "using">
}

//KEIL: Data Types
TOKEN : {
	<BIT: "bit"> |
	<SBIT: "sbit"> |
	<SFR: "sfr"> |
	<SFR16: "sfr16">
}

//KEIL:others
TOKEN : {
	<AT: "_at_"> |
	<ALIEN: "alien"> |
	<PRIORITY: "_priority_"> |
	<TASK: "_task_">
}
*/
TOKEN : {
	<CODE: "code"> |		//program memory
	<DATA: "data"> |		//internal data memory
	<IDATA: "idata"> |
	<BDATA: "bdata"> |
	<XDATA: "xdata"> |		//external data memory
	<PDATA: "pdata"> |
	<SMALL: "small"> |
	<COMPACT: "compact"> |
	<LARGE: "large"> |
	<REENTRANT: "reentrant"> |
	<INTERRUPT: "interrupt"> |
	<USING: "using"> |
	<BIT: "bit"> |
	<SBIT: "sbit"> |
	<SFR: "sfr"> |
	<SFR16: "sfr16"> |
	<AT: "_at_"> |
	<ALIEN: "alien"> |
	<PRIORITY: "_priority_"> |
	<TASK: "_task_"> |
	<CONTINUE: "continue"> |
	<VOLATILE: "volatile"> |
	<REGISTER: "register"> |
	<UNSIGNED: "unsigned"> |
	<TYPEDEF: "typedef"> |
	<DFLT: "default"> |
	<DOUBLE: "double"> |
	<SIZEOF: "sizeof"> |
	<SWITCH: "switch"> |
	<RETURN: "return"> |
	<EXTERN: "extern"> |
	<STRUCT: "struct"> |
	<STATIC: "static"> |
	<SIGNED: "signed"> |
	<WHILE: "while"> |
	<BREAK: "break"> |
	<UNION: "union"> |
	<CONST: "const"> |
	<FLOAT: "float"> |
	<SHORT: "short"> |
	<ELSE: "else"> |
	<CASE: "case"> |
	<LONG: "long"> |
	<ENUM: "enum"> |
	<AUTO: "auto"> |
	<VOID: "void"> |
	<CHAR: "char"> |
	<GOTO: "goto"> |
	<FOR: "for"> |
	<INT: "int"> |
	<IF: "if"> |
	<DO: "do"> |
	<SEMICOLON: ";"> |
	<LEFTCURLYBRACKETS: "{"> |
	<RIGHTCURLYBRACKETS: "}"> |
	<COMMA:",">|
	<FAR:"far">|
	<NEAR:"near">
}

TOKEN : {
 <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
|  <#DIGIT: ["0"-"9"]>
}

ASTTranslationUnit TranslationUnit() : {/*@bgen(jjtree) TranslationUnit */
  ASTTranslationUnit jjtn000 = new ASTTranslationUnit(this, JJTTRANSLATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TranslationUnit */
        try {
/*@egen*/
	(ExternalDeclaration())+/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//keil:
void ExternalDeclaration() : {/*@bgen(jjtree) ExternalDeclaration */
  ASTExternalDeclaration jjtn000 = new ASTExternalDeclaration(this, JJTEXTERNALDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExternalDeclaration */
        try {
/*@egen*/
	try{
	( LOOKAHEAD( [DeclarationSpecifiers()] Declarator() [ MemoryModel() ] [ Reentrant() ] [ Interrupt() ] [ Using() ] [ Task() ] [ Priority() ] [ DeclarationList() ] "{" ) FunctionDefinition() | Declaration())
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//KEIL: integer const
/*
void IntegerConstant() : {Token t;}
{
	(
		t=<INTEGER_LITERAL>
 	) {jjtThis.setImage(t.image);}
}
*/

//KEIL: 
void Interrupt() : {/*@bgen(jjtree) Interrupt */
  ASTInterrupt jjtn000 = new ASTInterrupt(this, JJTINTERRUPT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Interrupt */
        try {
/*@egen*/
	<INTERRUPT> <INTEGER_LITERAL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void Using() : {/*@bgen(jjtree) Using */
  ASTUsing jjtn000 = new ASTUsing(this, JJTUSING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Using */
        try {
/*@egen*/
	<USING> <INTEGER_LITERAL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void Reentrant() : {/*@bgen(jjtree) Reentrant */
                    ASTReentrant jjtn000 = new ASTReentrant(this, JJTREENTRANT);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Reentrant */
        try {
/*@egen*/
	<REENTRANT>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void Priority() : {/*@bgen(jjtree) Priority */
                   ASTPriority jjtn000 = new ASTPriority(this, JJTPRIORITY);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Priority */
        try {
/*@egen*/
	<PRIORITY> <INTEGER_LITERAL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void Task() : {/*@bgen(jjtree) Task */
               ASTTask jjtn000 = new ASTTask(this, JJTTASK);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Task */
        try {
/*@egen*/
	<TASK> <INTEGER_LITERAL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void MemoryModel() : {/*@bgen(jjtree) MemoryModel */
                      ASTMemoryModel jjtn000 = new ASTMemoryModel(this, JJTMEMORYMODEL);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) MemoryModel */
        try {
/*@egen*/
	(
		t=<SMALL>
		| t=<COMPACT>
		| t=<LARGE>
 	)/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {jjtn000.setImage(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//KEIL: function type
void FunctionDefinition() : {/*@bgen(jjtree) FunctionDefinition */
  ASTFunctionDefinition jjtn000 = new ASTFunctionDefinition(this, JJTFUNCTIONDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionDefinition */
        try {
/*@egen*/
	/*[LOOKAHEAD(DeclarationSpecifiers()) DeclarationSpecifiers()] 
	Declarator() 
	[ DeclarationList() ]
	CompoundStatement()*/
	
	[LOOKAHEAD(DeclarationSpecifiers()) DeclarationSpecifiers()] 
	Declarator()
	[ MemoryModel() ]
	[ Reentrant() ]
	[ Interrupt() ]
	[ Using() ]
	[ Task() ]
	[ Priority() ]
	[ DeclarationList() ]
	CompoundStatement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Declaration() : {/*@bgen(jjtree) Declaration */
  ASTDeclaration jjtn000 = new ASTDeclaration(this, JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declaration */
        try {
/*@egen*/
	try{
	DeclarationSpecifiers() [ InitDeclaratorList() ] <SEMICOLON>
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
	}finally{
		// Finished with a typedefDeclaration??//Move this from InitDeclaratorList,beacause the InitDeclaratorList maybe absent(by wuzijing)
		if(!(typedefParsingStack.empty()) && ((Boolean)typedefParsingStack.peek()).booleanValue()){
		   	popTypedefParsingStack("Encounter InitDeclaratorList end");
	    }
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DeclarationList() : {/*@bgen(jjtree) DeclarationList */
  ASTDeclarationList jjtn000 = new ASTDeclarationList(this, JJTDECLARATIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeclarationList */
        try {
/*@egen*/
	(Declaration())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DeclarationSpecifiers() : {/*@bgen(jjtree) DeclarationSpecifiers */
  ASTDeclarationSpecifiers jjtn000 = new ASTDeclarationSpecifiers(this, JJTDECLARATIONSPECIFIERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeclarationSpecifiers */
          try {
/*@egen*/
	  StorageClassSpecifier() [ LOOKAHEAD(DeclarationSpecifiers())
	        DeclarationSpecifiers() ] |
	  TypeSpecifier()  [ LOOKAHEAD(DeclarationSpecifiers())
	        DeclarationSpecifiers() ] |
	  TypeQualifier() [ LOOKAHEAD(DeclarationSpecifiers())
	        DeclarationSpecifiers() ]/*@bgen(jjtree)*/
          } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              throw (RuntimeException)jjte000;
            }
            if (jjte000 instanceof ParseException) {
              throw (ParseException)jjte000;
            }
            throw (Error)jjte000;
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/ 
}

void StorageClassSpecifier() : {/*@bgen(jjtree) StorageClassSpecifier */
  ASTStorageClassSpecifier jjtn000 = new ASTStorageClassSpecifier(this, JJTSTORAGECLASSSPECIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StorageClassSpecifier */
        try {
/*@egen*/
	( <AUTO> | <REGISTER> | <STATIC> | <EXTERN> | <TYPEDEF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		pushTypedefParsingStack(Boolean.TRUE,"Encounter a StorageClassSpecifier");
	} )/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//KEIL: add Data Types
void TypeSpecifier() : {/*@bgen(jjtree) TypeSpecifier */
  ASTTypeSpecifier jjtn000 = new ASTTypeSpecifier(this, JJTTYPESPECIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeSpecifier */
        try {
/*@egen*/
	( 
	  <BIT>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {jjtn000.setImage("bit");}
	| <SBIT>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.setImage("sbit");}
	| <SFR>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {jjtn000.setImage("sfr");}
	| <SFR16>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.setImage("sfr16");}
	| <VOID>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.setImage("void");}
	| <CHAR>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.setImage("char");}
	| <SHORT>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.setImage("short");}
	| <INT>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {jjtn000.setImage("int");}
	| <LONG>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.setImage("long");}
	| <FLOAT>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.setImage("float");}
	| <DOUBLE>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setImage("double");}
	| <SIGNED>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setImage("signed");}
	| <UNSIGNED>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {jjtn000.setImage("unsigned");}
	| StructOrUnionSpecifier() 
	| EnumSpecifier() 
	| LOOKAHEAD( { isType(getToken(1).image) } ) TypedefName() 
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//KEIL: add Memory Types
void TypeQualifier() : {/*@bgen(jjtree) TypeQualifier */
  ASTTypeQualifier jjtn000 = new ASTTypeQualifier(this, JJTTYPEQUALIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeQualifier */
        try {
/*@egen*/
	( <CONST> | <VOLATILE> |<FAR> |<NEAR> | <CODE> | <DATA>  | <IDATA> | <BDATA> | <XDATA> | <PDATA> | <ALIEN>)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StructOrUnionSpecifier() : {/*@bgen(jjtree) StructOrUnionSpecifier */
  ASTStructOrUnionSpecifier jjtn000 = new ASTStructOrUnionSpecifier(this, JJTSTRUCTORUNIONSPECIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StructOrUnionSpecifier */
        try {
/*@egen*/
	{
			pushTypedefParsingStack(Boolean.FALSE,"Enter Union&Struct");
	}
	try{
		StructOrUnion() ( LOOKAHEAD(3) [ <IDENTIFIER> ] 
		<LEFTCURLYBRACKETS> 
		{
			structStack.push(Boolean.TRUE);
		}
		try {
			StructDeclarationList() 
		} catch (Exception ex) {
			DeclarationException(ex);
		} finally {
			structStack.pop();
		}
		<RIGHTCURLYBRACKETS> | <IDENTIFIER> )
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
	}finally{
		popTypedefParsingStack("Enter Union&Struct");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StructOrUnion() : {/*@bgen(jjtree) StructOrUnion */
  ASTStructOrUnion jjtn000 = new ASTStructOrUnion(this, JJTSTRUCTORUNION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StructOrUnion */
        try {
/*@egen*/
	( <STRUCT> | <UNION> )/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StructDeclarationList() : {/*@bgen(jjtree) StructDeclarationList */
  ASTStructDeclarationList jjtn000 = new ASTStructDeclarationList(this, JJTSTRUCTDECLARATIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StructDeclarationList */
        try {
/*@egen*/
	(StructDeclaration())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void InitDeclaratorList() : {/*@bgen(jjtree) InitDeclaratorList */
  ASTInitDeclaratorList jjtn000 = new ASTInitDeclaratorList(this, JJTINITDECLARATORLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InitDeclaratorList */
        try {
/*@egen*/
	try{
	InitDeclarator() (<COMMA> InitDeclarator())*
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
	}finally{
		
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//Keil:add _at_ declaration
void InitDeclarator() : {/*@bgen(jjtree) InitDeclarator */
  ASTInitDeclarator jjtn000 = new ASTInitDeclarator(this, JJTINITDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InitDeclarator */
        try {
/*@egen*/
	Declarator() [ "=" Initializer() | <AT> <INTEGER_LITERAL> ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StructDeclaration() : {/*@bgen(jjtree) StructDeclaration */
  ASTStructDeclaration jjtn000 = new ASTStructDeclaration(this, JJTSTRUCTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StructDeclaration */
        try {
/*@egen*/
	try{
	SpecifierQualifierList() 
	[StructDeclaratorList()]
	<SEMICOLON>
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SpecifierQualifierList() : {/*@bgen(jjtree) SpecifierQualifierList */
  ASTSpecifierQualifierList jjtn000 = new ASTSpecifierQualifierList(this, JJTSPECIFIERQUALIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SpecifierQualifierList */
          try {
/*@egen*/
	  TypeSpecifier() [ LOOKAHEAD(SpecifierQualifierList())
	        SpecifierQualifierList() ]|
	  TypeQualifier() [ LOOKAHEAD(SpecifierQualifierList())
	        SpecifierQualifierList() ]/*@bgen(jjtree)*/
          } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              throw (RuntimeException)jjte000;
            }
            if (jjte000 instanceof ParseException) {
              throw (ParseException)jjte000;
            }
            throw (Error)jjte000;
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/
}

void StructDeclaratorList() : {/*@bgen(jjtree) StructDeclaratorList */
  ASTStructDeclaratorList jjtn000 = new ASTStructDeclaratorList(this, JJTSTRUCTDECLARATORLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StructDeclaratorList */
        try {
/*@egen*/
	StructDeclarator() ( <COMMA> StructDeclarator() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StructDeclarator() : {/*@bgen(jjtree) StructDeclarator */
  ASTStructDeclarator jjtn000 = new ASTStructDeclarator(this, JJTSTRUCTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StructDeclarator */
        try {
/*@egen*/
	LOOKAHEAD([Declarator()] ":")
	[ Declarator() ] ":" ConstantExpression() 
	|Declarator()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	//( LOOKAHEAD(3) Declarator() | [ Declarator() ] ":" ConstantExpression() )
}

void EnumSpecifier() : {/*@bgen(jjtree) EnumSpecifier */
  ASTEnumSpecifier jjtn000 = new ASTEnumSpecifier(this, JJTENUMSPECIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EnumSpecifier */
        try {
/*@egen*/
	<ENUM> ( LOOKAHEAD(3) [ <IDENTIFIER> ] <LEFTCURLYBRACKETS> EnumeratorList() [<COMMA>] <RIGHTCURLYBRACKETS> | <IDENTIFIER> )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void EnumeratorList() : {/*@bgen(jjtree) EnumeratorList */
  ASTEnumeratorList jjtn000 = new ASTEnumeratorList(this, JJTENUMERATORLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EnumeratorList */
        try {
/*@egen*/
	Enumerator() (LOOKAHEAD(2)  <COMMA> Enumerator())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Enumerator() : {/*@bgen(jjtree) Enumerator */
  ASTEnumerator jjtn000 = new ASTEnumerator(this, JJTENUMERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Enumerator */
        try {
/*@egen*/
	<IDENTIFIER> [ "=" ConstantExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	 
	
}

//keil:poiters which point to a function such as "void (code *pTask)(void);"
void Declarator() : {/*@bgen(jjtree) Declarator */
  ASTDeclarator jjtn000 = new ASTDeclarator(this, JJTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declarator */
        try {
/*@egen*/
	[TypeQualifier()] [ Pointer() ] DirectDeclarator()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DirectDeclarator() : {/*@bgen(jjtree) DirectDeclarator */
                            ASTDirectDeclarator jjtn000 = new ASTDirectDeclarator(this, JJTDIRECTDECLARATOR);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) DirectDeclarator */
        try {
/*@egen*/
	( t = <IDENTIFIER>

	{ 
		jjtn000.setImage(t.image);
		if(!(typedefParsingStack.empty()) && ((Boolean)typedefParsingStack.peek()).booleanValue()){
			addType(t.image);
	  	}
	}
	 | "(" Declarator() ")" )

	( "[" [ ConstantExpression() ] "]" |
	    LOOKAHEAD(3) "(" ParameterTypeList() ")" |
	    "(" [ IdentifierList() ] ")" )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//keil:poiters which point to a function such as "void (code *pTask)(void);"
void Pointer() : {/*@bgen(jjtree) Pointer */
  ASTPointer jjtn000 = new ASTPointer(this, JJTPOINTER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Pointer */
        try {
/*@egen*/
	//(TypeQualifier())* "*" [ Pointer() ]
	//LOOKAHEAD(TypeQualifier() "*") TypeQualifier() "*" [ TypeQualifierList() ] [ Pointer() ]
	//| 
	"*" [ TypeQualifierList() ] [ Pointer() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeQualifierList() : {/*@bgen(jjtree) TypeQualifierList */
  ASTTypeQualifierList jjtn000 = new ASTTypeQualifierList(this, JJTTYPEQUALIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeQualifierList */
        try {
/*@egen*/
	(TypeQualifier())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ParameterTypeList() : {/*@bgen(jjtree) ParameterTypeList */
  ASTParameterTypeList jjtn000 = new ASTParameterTypeList(this, JJTPARAMETERTYPELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterTypeList */
        try {
/*@egen*/
	{ 
		pushTypedefParsingStack(Boolean.FALSE,"Enter ParameterTypeList");
	}
	try{
	ParameterList() [<COMMA> "..." ]
	}catch(Exception e){
		DeclarationException(e);
	}finally{
		popTypedefParsingStack("Exit ParameterTypeList");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ParameterList() : {/*@bgen(jjtree) ParameterList */
  ASTParameterList jjtn000 = new ASTParameterList(this, JJTPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterList */
        try {
/*@egen*/
	ParameterDeclaration() (LOOKAHEAD(2) <COMMA> ParameterDeclaration())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ParameterDeclaration() : {/*@bgen(jjtree) ParameterDeclaration */
  ASTParameterDeclaration jjtn000 = new ASTParameterDeclaration(this, JJTPARAMETERDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterDeclaration */
        try {
/*@egen*/
	DeclarationSpecifiers() ( LOOKAHEAD(Declarator()) Declarator() | [ AbstractDeclarator() ] )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void IdentifierList() : {/*@bgen(jjtree) IdentifierList */
  ASTIdentifierList jjtn000 = new ASTIdentifierList(this, JJTIDENTIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IdentifierList */
        try {
/*@egen*/
	<IDENTIFIER> (<COMMA> <IDENTIFIER>)*/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Initializer() : {/*@bgen(jjtree) Initializer */
  ASTInitializer jjtn000 = new ASTInitializer(this, JJTINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Initializer */
        try {
/*@egen*/
	( AssignmentExpression() |
	  <LEFTCURLYBRACKETS> InitializerList() [<COMMA>] <RIGHTCURLYBRACKETS> )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void InitializerList() : {/*@bgen(jjtree) InitializerList */
  ASTInitializerList jjtn000 = new ASTInitializerList(this, JJTINITIALIZERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InitializerList */
        try {
/*@egen*/
	Initializer() (LOOKAHEAD(2) <COMMA> Initializer())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeName() : {/*@bgen(jjtree) TypeName */
  ASTTypeName jjtn000 = new ASTTypeName(this, JJTTYPENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeName */
        try {
/*@egen*/
	SpecifierQualifierList() [ AbstractDeclarator() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

void AbstractDeclarator() : {/*@bgen(jjtree) AbstractDeclarator */
  ASTAbstractDeclarator jjtn000 = new ASTAbstractDeclarator(this, JJTABSTRACTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AbstractDeclarator */
        try {
/*@egen*/
	( LOOKAHEAD(3) Pointer() |
	  [Pointer()] DirectAbstractDeclarator() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DirectAbstractDeclarator() : {/*@bgen(jjtree) DirectAbstractDeclarator */
  ASTDirectAbstractDeclarator jjtn000 = new ASTDirectAbstractDeclarator(this, JJTDIRECTABSTRACTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DirectAbstractDeclarator */
        try {
/*@egen*/
	( LOOKAHEAD(2) "(" AbstractDeclarator() ")"{jjtn000.setOperatorType("(");} |
	               "[" [ConstantExpression()] "]"{jjtn000.setOperatorType("[");} |
	               "(" [ParameterTypeList()] ")"{jjtn000.setOperatorType("(");} )

	  ( "[" [ ConstantExpression() ] "]"{jjtn000.setOperatorType("[");} | "(" [ ParameterTypeList() ] ")"{jjtn000.setOperatorType("(");} )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypedefName() : {/*@bgen(jjtree) TypedefName */
  ASTTypedefName jjtn000 = new ASTTypedefName(this, JJTTYPEDEFNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypedefName */
        try {
/*@egen*/
	<IDENTIFIER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Statement() : {/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(this, JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
        try {
/*@egen*/
	try{
	( LOOKAHEAD(2) LabeledStatement() |
	  ExpressionStatement() |
	  CompoundStatement() |
	  SelectionStatement() |
	  IterationStatement() |
	  JumpStatement() )
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
		/*( LOOKAHEAD(2) LabeledStatement() |
	  ExpressionStatement() |
	  CompoundStatement() |
	  SelectionStatement() |
	  IterationStatement() |
	  JumpStatement() )*/
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LabeledStatement() : {/*@bgen(jjtree) LabeledStatement */
  ASTLabeledStatement jjtn000 = new ASTLabeledStatement(this, JJTLABELEDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LabeledStatement */
        try {
/*@egen*/
	( <IDENTIFIER> ":" Statement() |
	  <CASE> ConstantExpression() ":" Statement() |
	  <DFLT> ":" Statement() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExpressionStatement() : {/*@bgen(jjtree) ExpressionStatement */
  ASTExpressionStatement jjtn000 = new ASTExpressionStatement(this, JJTEXPRESSIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExpressionStatement */
        try {
/*@egen*/
	[ Expression() ] <SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CompoundStatement() : {/*@bgen(jjtree) CompoundStatement */
  ASTCompoundStatement jjtn000 = new ASTCompoundStatement(this, JJTCOMPOUNDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompoundStatement */
        try {
/*@egen*/
	<LEFTCURLYBRACKETS> 
		[ LOOKAHEAD(DeclarationList()) DeclarationList() ]
	    [ StatementList() ]
	<RIGHTCURLYBRACKETS>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StatementList() : {/*@bgen(jjtree) StatementList */
  ASTStatementList jjtn000 = new ASTStatementList(this, JJTSTATEMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StatementList */
        try {
/*@egen*/	
	try{
	(Statement())+
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SelectionStatement() : {/*@bgen(jjtree) SelectionStatement */
  ASTSelectionStatement jjtn000 = new ASTSelectionStatement(this, JJTSELECTIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SelectionStatement */
        try {
/*@egen*/
	( <IF> "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ] |
	  <SWITCH> "(" Expression() ")" Statement() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void IterationStatement() : {/*@bgen(jjtree) IterationStatement */
  ASTIterationStatement jjtn000 = new ASTIterationStatement(this, JJTITERATIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IterationStatement */
        try {
/*@egen*/
	( <WHILE> "(" Expression() ")" Statement() |
	  <DO> Statement() <WHILE> "(" Expression() ")" <SEMICOLON> |
	  <FOR> "(" [ Expression(){jjtn000.forChild[0]=true;} ] <SEMICOLON> [ Expression(){jjtn000.forChild[1]=true;} ] <SEMICOLON> [ Expression(){jjtn000.forChild[2]=true;} ] ")" Statement() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JumpStatement() : {/*@bgen(jjtree) JumpStatement */
  ASTJumpStatement jjtn000 = new ASTJumpStatement(this, JJTJUMPSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JumpStatement */
        try {
/*@egen*/
	( <GOTO> <IDENTIFIER> <SEMICOLON> |
	  <CONTINUE> <SEMICOLON> |
	  <BREAK> <SEMICOLON> |
	  <RETURN> [ Expression() ] <SEMICOLON> )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Expression() : {/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(this, JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	AssignmentExpression() ( <COMMA> AssignmentExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AssignmentExpression() : {/*@bgen(jjtree) AssignmentExpression */
  ASTAssignmentExpression jjtn000 = new ASTAssignmentExpression(this, JJTASSIGNMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignmentExpression */
          try {
/*@egen*/
	  LOOKAHEAD(UnaryExpression() AssignmentOperator()) UnaryExpression() AssignmentOperator() AssignmentExpression() |
	  LOOKAHEAD(3) ConditionalExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              throw (RuntimeException)jjte000;
            }
            if (jjte000 instanceof ParseException) {
              throw (ParseException)jjte000;
            }
            throw (Error)jjte000;
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/
}

void AssignmentOperator() : {/*@bgen(jjtree) AssignmentOperator */
  ASTAssignmentOperator jjtn000 = new ASTAssignmentOperator(this, JJTASSIGNMENTOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignmentOperator */
        try {
/*@egen*/
	( "="/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/{jjtn000.setOperatorType("=");} | "*="/*@bgen(jjtree)*/
                                                    {
                                                      jjtree.closeNodeScope(jjtn000, true);
                                                      jjtc000 = false;
                                                    }
/*@egen*/ {jjtn000.setOperatorType("*=");} | "/="/*@bgen(jjtree)*/
                                                                                            {
                                                                                              jjtree.closeNodeScope(jjtn000, true);
                                                                                              jjtc000 = false;
                                                                                            }
/*@egen*/ {jjtn000.setOperatorType("/=");}  | "%="/*@bgen(jjtree)*/
                                                                                                                                     {
                                                                                                                                       jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                       jjtc000 = false;
                                                                                                                                     }
/*@egen*/ {jjtn000.setOperatorType("%=");}  | "+="/*@bgen(jjtree)*/
                                                                                                                                                                               {
                                                                                                                                                                                 jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                 jjtc000 = false;
                                                                                                                                                                               }
/*@egen*/  {jjtn000.setOperatorType("+=");} | "-="/*@bgen(jjtree)*/
                                                                                                                                                                                                                        {
                                                                                                                                                                                                                          jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                          jjtc000 = false;
                                                                                                                                                                                                                        }
/*@egen*/  {jjtn000.setOperatorType("-=");} | "<<="/*@bgen(jjtree)*/
                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                   jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                                                   jjtc000 = false;
                                                                                                                                                                                                                                                                 }
/*@egen*/ {jjtn000.setOperatorType("<<=");}  | ">>="/*@bgen(jjtree)*/
                                                                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                                                                                               jjtc000 = false;
                                                                                                                                                                                                                                                                                                             }
/*@egen*/  {jjtn000.setOperatorType(">>=");} | "&="/*@bgen(jjtree)*/
                                                                                                                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                                                                                                                         jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                                                                                                                                         jjtc000 = false;
                                                                                                                                                                                                                                                                                                                                                       }
/*@egen*/  {jjtn000.setOperatorType("&=");} | "^="/*@bgen(jjtree)*/
                                                                                                                                                                                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                                                                                                                                                                                 jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                                                                                                                                                                                 jjtc000 = false;
                                                                                                                                                                                                                                                                                                                                                                                               }
/*@egen*/ {jjtn000.setOperatorType("^=");}  | "|="/*@bgen(jjtree)*/
                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                          jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                                                                                                                                                                                                                          jjtc000 = false;
                                                                                                                                                                                                                                                                                                                                                                                                                                        }
/*@egen*/ {jjtn000.setOperatorType("|=");}  )/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}


void ConditionalExpression()                           : {/*@bgen(jjtree) #ConditionalExpression(> 1) */
  ASTConditionalExpression jjtn000 = new ASTConditionalExpression(this, JJTCONDITIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #ConditionalExpression(> 1) */
        try {
/*@egen*/
	LogicalORExpression() [ "?" Expression() ":" ConditionalExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void ConstantExpression() : {/*@bgen(jjtree) ConstantExpression */
  ASTConstantExpression jjtn000 = new ASTConstantExpression(this, JJTCONSTANTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConstantExpression */
        try {
/*@egen*/
	ConditionalExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LogicalORExpression()                         : {/*@bgen(jjtree) #LogicalORExpression(> 1) */
  ASTLogicalORExpression jjtn000 = new ASTLogicalORExpression(this, JJTLOGICALOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #LogicalORExpression(> 1) */
        try {
/*@egen*/
	LogicalANDExpression() ( "||"  {jjtn000.setOperatorType("||");}LogicalANDExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void LogicalANDExpression()                          : {/*@bgen(jjtree) #LogicalANDExpression(> 1) */
  ASTLogicalANDExpression jjtn000 = new ASTLogicalANDExpression(this, JJTLOGICALANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #LogicalANDExpression(> 1) */
        try {
/*@egen*/
	InclusiveORExpression() ( "&&"{jjtn000.setOperatorType("&&");} InclusiveORExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void InclusiveORExpression()                           : {/*@bgen(jjtree) #InclusiveORExpression(> 1) */
  ASTInclusiveORExpression jjtn000 = new ASTInclusiveORExpression(this, JJTINCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #InclusiveORExpression(> 1) */
        try {
/*@egen*/
	ExclusiveORExpression() ( "|" {jjtn000.setOperatorType("|");} ExclusiveORExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void ExclusiveORExpression()                           : {/*@bgen(jjtree) #ExclusiveORExpression(> 1) */
  ASTExclusiveORExpression jjtn000 = new ASTExclusiveORExpression(this, JJTEXCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #ExclusiveORExpression(> 1) */
        try {
/*@egen*/
	ANDExpression() ( "^"  {jjtn000.setOperatorType("^");}ANDExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void ANDExpression()                   : {/*@bgen(jjtree) #ANDExpression(> 1) */
  ASTANDExpression jjtn000 = new ASTANDExpression(this, JJTANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #ANDExpression(> 1) */
        try {
/*@egen*/
	EqualityExpression() ( LOOKAHEAD(2) "&"{jjtn000.setOperatorType("&");} EqualityExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void EqualityExpression()                        : {/*@bgen(jjtree) #EqualityExpression(> 1) */
  ASTEqualityExpression jjtn000 = new ASTEqualityExpression(this, JJTEQUALITYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #EqualityExpression(> 1) */
        try {
/*@egen*/
	RelationalExpression() ( ( "==" {jjtn000.setOperatorType("==");}| "!=" {jjtn000.setOperatorType("!=");} ) RelationalExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void RelationalExpression()                          : {/*@bgen(jjtree) #RelationalExpression(> 1) */
  ASTRelationalExpression jjtn000 = new ASTRelationalExpression(this, JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #RelationalExpression(> 1) */
        try {
/*@egen*/
	ShiftExpression() ( LOOKAHEAD(2) ( "<" {jjtn000.setOperatorType("<");}  | ">" {jjtn000.setOperatorType(">");}  | "<="  {jjtn000.setOperatorType("<=");} | ">=" {jjtn000.setOperatorType(">=");}  )  ShiftExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void ShiftExpression()                     : {/*@bgen(jjtree) #ShiftExpression(> 1) */
  ASTShiftExpression jjtn000 = new ASTShiftExpression(this, JJTSHIFTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #ShiftExpression(> 1) */
        try {
/*@egen*/
	AdditiveExpression() ( ( "<<" {jjtn000.setOperatorType("<<");}  | ">>"  {jjtn000.setOperatorType(">>");} )  AdditiveExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void AdditiveExpression()                        : {/*@bgen(jjtree) #AdditiveExpression(> 1) */
  ASTAdditiveExpression jjtn000 = new ASTAdditiveExpression(this, JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #AdditiveExpression(> 1) */
        try {
/*@egen*/
	MultiplicativeExpression() (LOOKAHEAD(2) ( "+" {jjtn000.setOperatorType("+");}  | "-"  {jjtn000.setOperatorType("-");} ) MultiplicativeExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void MultiplicativeExpression()                              : {/*@bgen(jjtree) #MultiplicativeExpression(> 1) */
  ASTMultiplicativeExpression jjtn000 = new ASTMultiplicativeExpression(this, JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #MultiplicativeExpression(> 1) */
        try {
/*@egen*/
	CastExpression()  (LOOKAHEAD(2) ( "*"  {jjtn000.setOperatorType("*");} | "/" {jjtn000.setOperatorType("/");}  | "%" {jjtn000.setOperatorType("%");}  ) CastExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void CastExpression()                    : {/*@bgen(jjtree) #CastExpression(> 1) */
  ASTCastExpression jjtn000 = new ASTCastExpression(this, JJTCASTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #CastExpression(> 1) */
        try {
/*@egen*/
	( LOOKAHEAD("(" TypeName() ")" CastExpression() ) "(" TypeName() ")" CastExpression() |
	  UnaryExpression() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void UnaryExpression() : {/*@bgen(jjtree) UnaryExpression */
  ASTUnaryExpression jjtn000 = new ASTUnaryExpression(this, JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnaryExpression */
        try {
/*@egen*/
	( LOOKAHEAD(3) PostfixExpression() |
	  "++"  {jjtn000.setOperatorType("++");} UnaryExpression() |
	  "--" {jjtn000.setOperatorType("--");}  UnaryExpression() |
	  UnaryOperator() CastExpression() |
	  <SIZEOF> ( LOOKAHEAD(UnaryExpression() ) UnaryExpression() | "(" TypeName() ")" ) )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void UnaryOperator() : {/*@bgen(jjtree) UnaryOperator */
  ASTUnaryOperator jjtn000 = new ASTUnaryOperator(this, JJTUNARYOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnaryOperator */
        try {
/*@egen*/
	( "&"/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {jjtn000.setOperatorType("&");}  | "*"/*@bgen(jjtree)*/
                                                     {
                                                       jjtree.closeNodeScope(jjtn000, true);
                                                       jjtc000 = false;
                                                     }
/*@egen*/ {jjtn000.setOperatorType("*");}  | "+"/*@bgen(jjtree)*/
                                                                                            {
                                                                                              jjtree.closeNodeScope(jjtn000, true);
                                                                                              jjtc000 = false;
                                                                                            }
/*@egen*/ {jjtn000.setOperatorType("+");}  | "-"/*@bgen(jjtree)*/
                                                                                                                                   {
                                                                                                                                     jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                     jjtc000 = false;
                                                                                                                                   }
/*@egen*/ {jjtn000.setOperatorType("-");}  | "~"/*@bgen(jjtree)*/
                                                                                                                                                                          {
                                                                                                                                                                            jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                            jjtc000 = false;
                                                                                                                                                                          }
/*@egen*/ {jjtn000.setOperatorType("~");}  | "!"/*@bgen(jjtree)*/
                                                                                                                                                                                                                  {
                                                                                                                                                                                                                    jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                    jjtc000 = false;
                                                                                                                                                                                                                  }
/*@egen*/  {jjtn000.setOperatorType("!");} )/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PostfixExpression() : {/*@bgen(jjtree) PostfixExpression */
  ASTPostfixExpression jjtn000 = new ASTPostfixExpression(this, JJTPOSTFIXEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PostfixExpression */
        try {
/*@egen*/
	PrimaryExpression() ( "["{jjtn000.setOperatorType("[]");} Expression() "]" |
	                      "("{jjtn000.setOperatorType("()");} [ LOOKAHEAD(ArgumentExpressionList() ) ArgumentExpressionList() ] ")" |
	  					  "."  {jjtn000.setOperatorType(".");} <IDENTIFIER> |
	  					  "->" {jjtn000.setOperatorType("->");}  <IDENTIFIER> |
	  					  "++"  {jjtn000.setOperatorType("++");} |
	  					  "--"  {jjtn000.setOperatorType("--");} )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PrimaryExpression() : {/*@bgen(jjtree) PrimaryExpression */
                            ASTPrimaryExpression jjtn000 = new ASTPrimaryExpression(this, JJTPRIMARYEXPRESSION);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) PrimaryExpression */
        try {
/*@egen*/
	( t=<IDENTIFIER>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {jjtn000.setImage(t.image);} 
	| Constant() 
	| LOOKAHEAD(2) "(" Expression() ")"
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ArgumentExpressionList() : {/*@bgen(jjtree) ArgumentExpressionList */
  ASTArgumentExpressionList jjtn000 = new ASTArgumentExpressionList(this, JJTARGUMENTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArgumentExpressionList */
        try {
/*@egen*/
	AssignmentExpression() ( <COMMA> AssignmentExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Constant() : {/*@bgen(jjtree) Constant */
                   ASTConstant jjtn000 = new ASTConstant(this, JJTCONSTANT);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Constant */
        try {
/*@egen*/
	(
		t=<INTEGER_LITERAL> 
 	|	t=<FLOATING_POINT_LITERAL>
 	|	t=<CHARACTER_LITERAL>
 	|	(t=<STRING_LITERAL>)+
 	)/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {jjtn000.setImage(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}