/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. gcc.jj */
/*@egen*//*

  C grammar defintion for use with JavaCC
  Contributed by Doug South (dsouth@squirrel.com.au) 21/3/97

  This parser assumes that the C source file has been preprocessed : all
  #includes have been included and all macros have been expanded. I accomplish
  this with "gcc -P -E <source file> > <output file>".

  There is a problem with compiler specific types, such as __signed, __const,
  __inline__, etc. These types can be added as typedef types before the parser
  is run on a file. See main() for an example. I have also found a strange little
  compiler specific "type" if you can call it that. It is __attribute__, but it
  does not seem to be used as a type. I found that just deleting the __attribute__
  and the following "offensive" code works.

  This grammar also prints out all the types defined while parsing the file. This
  is done via a call to printTypes() when the parser is complete. If you do not want
  this, just comment out the printTypes() method call in the production rule
  TranslationUnit(), which BTW is the root node for parsing a C source file.

  I have not in anyway extensively tested this grammar, in fact it is barely tested,
  but I imagine it is better to have a starting point for a C grammar other than from
  scratch. It has not been optimized in anyway, my main aim was to get a parser that
  works. Lookahead may not be optimum at choice points and may even be insufficient at
  times. I choose to err on the side of not optimum if I made a choice at all.

  If you use this grammar, I would appreciate hearing from you. I will try to maintain
  this grammar to the best of my ability, but at this point in time, this is only a side
  hobby (unless someone wants to pay me for doing JavaCC work!). In that regards, I am
  interested in hearing bugs and comments.

  TODO:

    Insert the appropriate code to enable C source trees from this grammar.

=============================================
3/2/06: Modified by Tom Copeland
- STRING_LITERAL now handles embedded escaped newlines, thanks to J.Chris Findlay for the patch
- Works with JavaCC 4.0
- Preprocessor directives are now simply SKIP'd, so no need to run C files through GCC first

  */
options {
  BUILD_PARSER=true;
  JAVA_UNICODE_ESCAPE = true;
  CACHE_TOKENS = true;
  STATIC = false;
  USER_CHAR_STREAM = true;
  
               
                 
  
                       
  
                          
  OUTPUT_DIRECTORY = "gcc";
  
                                          
}

PARSER_BEGIN(CParser_GCC)

package softtest.ast.gccparser.c;

import softtest.ast.c.*;
import java.io.*;

public class CParser_GCC extends CParser/*@bgen(jjtree)*/implements CParser_GCCTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTCParser_GCCState jjtree = new JJTCParser_GCCState();

/*@egen*/
	public ASTTranslationUnit createAST(java.io.StringReader input) {
        try {
			CCharStream ccs = new CCharStream(input);
			CParser parser = new CParser_GCC(ccs);
			ASTTranslationUnit astcu = parser.TranslationUnit();
			System.out.println("parsed successfully :) ");
			return astcu;
		} catch (ParseException pe) {
			pe.printStackTrace();
			return null;
		}
	}

	public ASTTranslationUnit parser(String inputfile){
		CParser parser = null;
		ASTTranslationUnit astroot = null;
		try {
			parser = new CParser_GCC(new CCharStream(new FileInputStream(inputfile)));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

		try {
			astroot = parser.TranslationUnit();
		} catch (ParseException e) {
			e.printStackTrace();
		}
		return astroot;
	}

	void error_skipto(int kind,Exception in_exception) throws Exception{
		throw in_exception;
	}
		
	void error_skipto1(int kind,Exception in_exception) {
		//logger.error(in_exception.toString());
		ParseException e = generateParseException();
		StackTraceElement st[] = e.getStackTrace();
		/*for (int i = 0; i < st.length; i++) {
			logger.error(st[i]);
		}
		*/
		errorMsg.add(e.toString());

		Token t = getNextToken();
		t = getNextToken();
		int flag = 0;
		int bracketNum = 0, cbracketNum = 0;
		if (t.image.equals("(")) {
			flag = 1;
			bracketNum = 1;
		}else if(t.image.equals("{")) {
			flag = 2;
			cbracketNum = 1;
		}
		if (flag > 0) {
			while(bracketNum >= 0 ||cbracketNum >=0 ) {
				t = getNextToken();
				if (t.image.equals("(")) {
					bracketNum++;
				} else if (t.image.equals(")")) {
                			bracketNum--;
				} else if (t.image.equals("{")) {
					cbracketNum++;
				} else if (t.image.equals("}")) {
					cbracketNum--;
				}
				if (t.kind == CParser_GCCConstants.EOF || 
					(cbracketNum <=0 &&(t.kind==CParser_GCCConstants.SEMICOLON || jj_nt.kind == CParser_GCCConstants.RIGHTCURLYBRACKETS))) {
					return;
				}        
			}
		}

		do {
			t = getNextToken();
		} while (t.kind!=CParser_GCCConstants.EOF&&t.kind != kind);// The above loop consumes tokens all the way up to a token of

		// "kind".  We use a do-while loop rather than a while because the
		// current token is the one immediately before the erroneous token
		// (in our case the token immediately before what should have been
		// "if"/"while".
	}

	void DeclarationException(Exception ine){
		//logger.error(ine.toString());
		ParseException e = generateParseException();  // generate the exception object.
		StackTraceElement st[] = e.getStackTrace();
		/*for (int i = 0; i < st.length; i++) {
			logger.error(st[i]);
		}*/
	}
	
    boolean isPointer(){
		Token t1=getToken(1);
		Token t2=getToken(2);
		for(int i=3;i<1024;i++){
			if(t1.kind== CParser_GCCConstants.IDENTIFIER&&!isType(t1.image)){
				int count=0;
				if(t2.image.equals(")")){
					count++;
					Token t;
					for(int j=i;j<1024;j++){
						t=getToken(j);
						if(t.image.equals(")")){
							count++;
						}else{
							break;
						}
					}
					
					for(int j=i-2;j>0;j--){
						t=getToken(j);
						if(t.image.equals("*")){
							return true;
						}else if(t.image.equals("(")){
							count--;
							if(count==0){
								return false;
							}
						}
					}
				}
				return false;
			}
			t1=t2;
			t2=getToken(i);
		}
		return false;
	}
}

PARSER_END(CParser_GCC)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"

|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
|  <"asm" (" "|"\t") ("\t"|"\n"|"\r"|" "|"\r\n")* "{" (~["{","}"])* "}">
|  <("__asm"|"__asm__") (" "|"\t") ("\t"|"\n"|"\r"|" "|"\r\n")* "{" (~["{","}"])* "}">
|  <"asm" (" "|"\t") (~["\n","\r","}","{","("])* ("\n" | "\r" | "\r\n")?>
|  <("__asm"|"__asm__") (" "|"\t") (~["\n","\r","}","{","("])* ("\n" | "\r" | "\r\n")?>
|  <("__asm"|"asm"|"__asm__") (" "|"\t"|"\r"|"\n")* (~["\n","\r","}","{","("])* "("> {
	int leftbracketnum=1;//\u5de6\u62ec\u53f7\u7684\u4e2a\u6570
	char c;
	try{
		while(leftbracketnum>0&&(c=input_stream.readChar())>0){
			if (c==')') leftbracketnum--;
			if (c=='(') leftbracketnum++;
		}
		//xqing
		/*while((c=input_stream.readChar())>0){
			if (c==';'){
				break;
			}
			System.out.println("should be a <;> after __asm( <something> )");
		}*/
	}catch(Exception e){e.printStackTrace();}
   }
//GCC
//From defines.txt
| "__based(x)" | "_based(x)" 
| "__cdecl"| "_cdecl" 
| "__fastcall"| "_fastcall" 
| "__stdcall"| "_stdcall" 
| "__declspec(x)"| "_declspec(x)" 
| "__assume(x)"| "_assume(x)" 
| "__multiple_inheritance"| "_multiple_inheritance" 
| "__single_inheritance"| "_single_inheritance"
| "__virtual_inheritance"| "_virtual_inheritance"
| "__leave" | "_leave" 
| "__inline"| "_inline"| "__inline__"| "inline" 
| "__forceinline"| "_forceinline"
| "__ptr64"
| "__DJ_wint_t" 
//| "__volatile__"  
| "__attribute__(x)"
| "__asm__(x)"
| "__extension__"
| "NONAMELESSUNION"
| "NONAMELESSSTRUCT" 
| "__MINGW_ATTRIB_NORETURN"
| "__MINGW_ATTRIB_CONST"
| "__MINGW_ATTRIB_MALLOC"
| "__MINGW_ATTRIB_PURE" 
| "__CRT_INLINE"
| "__MINGW_IMPORT"
| "__MINGW_NOTHROW"
| "PACKED"
//End
|  < ("__attribute__" | "__attribute") (" "|"\t"|"\n"|"\r")* "((" > {
	leftbracketnum=2;//\u5de6\u62ec\u53f7\u7684\u4e2a\u6570
	try{
		while(leftbracketnum>0&&(c=input_stream.readChar())>0){
			if (c==')') leftbracketnum--;
			if (c=='(') leftbracketnum++;
		}
	}catch(Exception e){e.printStackTrace();}
    }
| "#" : PREPROCESSOR_OUTPUT
| "__restrict__"
| "__restrict"
| "restrict" //void f(int *restrict a[2], restrict ipa b, int *restrict c[restrict]); 
}

<PREPROCESSOR_OUTPUT> SKIP:
{
     "\n" 
     {
         if(image.length()>0){
         	String tempimage = image.toString();
			if (tempimage.startsWith("line") || tempimage.startsWith("Line")
					|| tempimage.startsWith(" ")) {
				String[] strs = tempimage.split(" ");
				boolean b = false;
				if (strs.length >= 2) {
					int newline = 0;
					String newfilename ="";
					if(strs.length>2){
 						newfilename= strs[2];
 						int i=3;
 						while(i<strs.length&&newfilename.startsWith("\"")&&!newfilename.endsWith("\"")){
 							newfilename= newfilename+" "+strs[i];
 							i++;
 						}
					}
					try {
						newline = Integer.parseInt(strs[1])-1;
						newfilename=newfilename.replace("/", "\\");
						newfilename=newfilename.replace("\\\\","\\");
						newfilename.intern();
						b = true;
					} catch (Exception e) {
					}
					if (b && (input_stream instanceof CCharStream)) {
						((CCharStream) input_stream)
								.adjustBeginLineAndFileName(newline,
										newfilename);
					}
				}
			}
         }
   }: DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
 "\\\n"
 |
 "\\\r\n"
 |
 < ~[] >
}

//added by zys:gcc complex nums
TOKEN : {
// modify to support vc style integer 	
	<COMPLEX_LITERAL: <INTEGER_LITERAL> ( ["i","I"] | ["j","J"] ) | <FLOATING_POINT_LITERAL> ( ["i","I"] | ["f","F"] | ["j","J"])* >
| <INTEGER_LITERAL: <DECIMAL_LITERAL> (((["u","U"])(["l","L"])?)?|((["l","L"])(["u","U"])?)?|("i64"|"LL"|"ll"|"ULL"|"ull"|"uLL"|"Ull"|"llu"|"LLU")?)
| <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?|<DECIMAL_LITERAL_UL>|<HEX_LITERAL_LLU>>
|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* | "0">//GCC: int i=~0ul;
|  <#DECIMAL_LITERAL_UL: ("0"(["1"-"9"])(["0"-"9"])* | "0")"UL">

|  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+(((["u","U"])(["l","L"])?)?|((["l","L"])(["u","U"])?))>
|  <#HEX_LITERAL_LLU: "0"(["x","X"])?(["0"-"9","a"-"f","A"-"F"])*"LLU">
|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
|  <FLOATING_POINT_LITERAL: <HEX_FLOATING_POINT_LITERAL> | (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D","w","W","q","Q","l","L"])* | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D","w","W","q","Q","l","L"])* | (["0"-"9"])+ <EXPONENT> (["f","F","d","D","w","W","q","Q","l","L"])* | (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D","w","W","q","Q","l","L"])*>
|		<#HEX_FLOATING_POINT_LITERAL: ("0x"|"0X") ( (["a"-"f","A"-"F","0"-"9"])+ "." (["a"-"f","A"-"F","0"-"9"])* <EXPONENT> (["f","F","d","D","w","W","q","Q","l","L"])* | "." (["a"-"f","A"-"F","0"-"9"])+ (<EXPONENT>) (["f","F","d","D","w","W","q","Q","l","L"])* | (["a"-"f","A"-"F","0"-"9"])+ <EXPONENT> (["f","F","d","D","w","W","q","Q","l","L"])* ) >
|  		<#EXPONENT: ["e","E","p","P"] (["+","-"])? (["0"-"9"])+>
|  <CHARACTER_LITERAL: ("L")? "\'" ((~["\'","\\","\n","\r"])* | "\\" (["0","e","a","v","n","t","b","r","f","?","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"]) |"\\x"(["0"-"9","a"-"f","A"-"F"])* ) "\'">
|  <STRING_LITERAL: ("L")?  "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["0","a","e","v","x","n","t","b","r","f","?","\\","\'","\"","%"," "] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
//added by qfx,GCC
|  <BINARY_LITERAL:"0b"(["0","1"])+>
}

TOKEN : {
	<BOOL: "_Bool"> |
	<THREAD: "__thread"> |
	<FUNC: "__func__" | <FUNC1> | <FUNC2> > |
		<#FUNC1: "__FUNCTION__"> |
		<#FUNC2: "__PRETTY_FUNCTION__"> |
	<ALIGNOF: "__alignof__" | "__alignof"> |
	<COMPLEX: "_Complex" | <OLDCOMPLEX> > |
		<#OLDCOMPLEX: "__complex__"> |
	<REAL: "__real__" | "__real"> |
	<IMAG: "__imag__" | "__imag"> |
	<TYPEOF: "typeof" | "__typeof" |<OLDTYPEOF> > |
		<#OLDTYPEOF: "__typeof__"> |
	<LABEL: "__label__"> |
	<CONTINUE: "continue"> |
	<VOLATILE: "volatile" | "__volatile" | "__volatile__"> |
	<REGISTER: "register"> |
	<UNSIGNED: "unsigned"> |
	<TYPEDEF: "typedef"> |
	<DFLT: "default"> |
	<DOUBLE: "double"> |
	<SIZEOF: "sizeof"> |
	<SWITCH: "switch"> |
	<RETURN: "return"> |
	<EXTERN: "extern"> |
	<STRUCT: "struct"> |
	<STATIC: "static"> |
	<SIGNED: "signed"|"__signed__"|"__signed"> |
	<WHILE: "while"> |
	<BREAK: "break"> |
	<UNION: "union"> |
	<CONST: "const" | "__const"> |
	//added by qfx 2013-5-8\uff1afloat16\u3001float32\u3001float64\u3001__float16\u3001__float32\u3001__float64
	<FLOAT: ("float"|"float16"|"float32"|"float64"|"__float16"|"__float32"|"__float64"|  <FLOAT80> | <FLOAT128>) >|
		<#FLOAT80: "__float80"> |
		<#FLOAT128: "__float128"> |
	<DECIMALFLOAT: "_Decimal32" | <DECIMALFLOAT64> | <DECIMALFLOAT128> > |
			<#DECIMALFLOAT64: "_Decimal64"> |
			<#DECIMALFLOAT128: "_Decimal128"> |
	<SHORT: "short"> |
	<ELSE: "else"> |
	<CASE: "case"> |
	<LONG: "long"> |
	<ENUM: "enum"> |
	<AUTO: "auto"> |
	<VOID: "void"> |
	<CHAR: "char"> |
	<GOTO: "goto"> |
	<FOR: "for"> |
	//added by qfx:int16_t\u3001int_least16_t\u3001int_fast32_t\u3001intmax_t\u3001uintmax_t\u3001uint8_t\u3001uint16_t\u3001uint32_t\u3001uint64_t\u3001int8\u3001int16\u3001int32\u3001int64\u3001size_t
	<INT: "int"|"__int8"|"__int16"|"__int32"|"__int64"|"int8"|"int16"|"int32"|"int64"|"int16_t"|"int_least16_t"|"int_fast32_t"|"intmax_t"|"uintmax_t"|"uint8_t"|"uint16_t"|"uint32_t"|"uint64_t"|"size_t"> |
	<IF: "if"> |
	<DO: "do"> |
	<SEMICOLON: ";"> |
	<LEFTCURLYBRACKETS: "{"> |
	<RIGHTCURLYBRACKETS: "}"> |
	<LEFTBRACKET: "["> |
	<RIGHTBRACKET: "]"> |
	<COMMA:",">|
	<EQUAL: "=" >|
	<FAR:"far"|"__far"|"xdata"|"__xdata">|
	<NEAR:"near"|"__near">
}

TOKEN : {
 <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
|  <#DIGIT: ["0"-"9"]>
}

ASTTranslationUnit TranslationUnit() : {/*@bgen(jjtree) TranslationUnit */
  ASTTranslationUnit jjtn000 = new ASTTranslationUnit(this, JJTTRANSLATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TranslationUnit */
        try {
/*@egen*/
	(ExternalDeclaration())*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExternalDeclaration() : {/*@bgen(jjtree) ExternalDeclaration */
  ASTExternalDeclaration jjtn000 = new ASTExternalDeclaration(this, JJTEXTERNALDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExternalDeclaration */
        try {
/*@egen*/
	try{
	LOOKAHEAD( [DeclarationSpecifiers()] Declarator() [ DeclarationList() ] "{" ) FunctionDefinition() 
	| LOOKAHEAD( FunctionDeclaration(),{getToken(1).kind!=CParser_GCCConstants.TYPEDEF &&!isPointer()} ) 
	  FunctionDeclaration()
	| Declaration()
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//gcc:
void FunctionDeclaration(): {/*@bgen(jjtree) FunctionDeclaration */
                             ASTFunctionDeclaration jjtn000 = new ASTFunctionDeclaration(this, JJTFUNCTIONDECLARATION);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;boolean flag=false;}
{/*@bgen(jjtree) FunctionDeclaration */
        try {
/*@egen*/
	[LOOKAHEAD(DeclarationSpecifiers()) DeclarationSpecifiers()] 
	[ Pointer() ] 
	( t = <IDENTIFIER>{ jjtn000.setImage(t.image);}
	|LOOKAHEAD("(" Declarator()")",{getToken(4).image=="("}) "(" Declarator(){flag=true;jjtn000.setOperatorTypeAndFlag("",flag);flag=false;} ")" 
	)
	( 
		LOOKAHEAD(3) "(" ParameterTypeList(){flag=true;} ")"{jjtn000.setOperatorTypeAndFlag("(",flag);flag=false;}  |
		"(" [ IdentifierList(){flag=true;} ] ")" {jjtn000.setOperatorTypeAndFlag("(",flag);flag=false;} 
	)+
		 	    	 
	[ DeclarationList() ]
	<SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void FunctionDefinition() : {/*@bgen(jjtree) FunctionDefinition */
  ASTFunctionDefinition jjtn000 = new ASTFunctionDefinition(this, JJTFUNCTIONDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionDefinition */
        try {
/*@egen*/
	[LOOKAHEAD(DeclarationSpecifiers()) DeclarationSpecifiers()] Declarator() [ DeclarationList() ]
	CompoundStatement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

////zys
void Declaration() : {/*@bgen(jjtree) Declaration */
  ASTDeclaration jjtn000 = new ASTDeclaration(this, JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declaration */
        try {
/*@egen*/
	try{
	 DeclarationSpecifiers() [ InitDeclaratorList() ] <SEMICOLON> 
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
	}finally{
		if(!(typedefParsingStack.empty()) && ((Boolean)typedefParsingStack.peek()).booleanValue()){
		   	popTypedefParsingStack("Encounter InitDeclaratorList end");
		}
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//GCC 5.4 add nested functions
void DeclarationList() : {/*@bgen(jjtree) DeclarationList */
  ASTDeclarationList jjtn000 = new ASTDeclarationList(this, JJTDECLARATIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeclarationList */
        try {
/*@egen*/
	( LOOKAHEAD(NestedFunctionDeclaration()) NestedFunctionDeclaration() |
	Declaration())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NestedFunctionDeclaration() : {/*@bgen(jjtree) NestedFunctionDeclaration */
                                    ASTNestedFunctionDeclaration jjtn000 = new ASTNestedFunctionDeclaration(this, JJTNESTEDFUNCTIONDECLARATION);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;boolean flag=false;}
{/*@bgen(jjtree) NestedFunctionDeclaration */
        try {
/*@egen*/
	<AUTO>
	[LOOKAHEAD(DeclarationSpecifiers()) DeclarationSpecifiers()] 
	[ Pointer() ] ( t=<IDENTIFIER>{jjtn000.setImage(t.image);} | "(" Declarator() {flag=true;jjtn000.setOperatorTypeAndFlag("",flag);flag=false;}")" )
	(
	 	LOOKAHEAD(3) "(" ParameterTypeList() {flag=true;} ")"{jjtn000.setOperatorTypeAndFlag("(",flag);flag=false;}  |
		"(" [ IdentifierList() {flag=true;} ] ")" {jjtn000.setOperatorTypeAndFlag("(",flag);flag=false;} 
	)+
	<SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void NestedFunctionDefinition() : {/*@bgen(jjtree) NestedFunctionDefinition */
  ASTNestedFunctionDefinition jjtn000 = new ASTNestedFunctionDefinition(this, JJTNESTEDFUNCTIONDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NestedFunctionDefinition */
        try {
/*@egen*/
	DeclarationSpecifiers() Declarator() [ DeclarationList() ] CompoundStatement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//GCC: add local label
void LabelDeclarationList() : {/*@bgen(jjtree) LabelDeclarationList */
  ASTLabelDeclarationList jjtn000 = new ASTLabelDeclarationList(this, JJTLABELDECLARATIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LabelDeclarationList */
        try {
/*@egen*/
	( LOOKAHEAD(LabelDeclaration()) LabelDeclaration() )+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void LabelDeclaration() : {/*@bgen(jjtree) LabelDeclaration */
  ASTLabelDeclaration jjtn000 = new ASTLabelDeclaration(this, JJTLABELDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LabelDeclaration */
        try {
/*@egen*/
	LabelType() LabelDeclaratorList() <SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void LabelDeclaratorList() : {/*@bgen(jjtree) LabelDeclaratorList */
  ASTLabelDeclaratorList jjtn000 = new ASTLabelDeclaratorList(this, JJTLABELDECLARATORLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LabelDeclaratorList */
        try {
/*@egen*/
	LabelDeclarator() (<COMMA> LabelDeclarator())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void LabelDeclarator() : {/*@bgen(jjtree) LabelDeclarator */
                          ASTLabelDeclarator jjtn000 = new ASTLabelDeclarator(this, JJTLABELDECLARATOR);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) LabelDeclarator */
        try {
/*@egen*/
	t=<IDENTIFIER>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/{jjtn000.setImage(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}
void LabelType() : {/*@bgen(jjtree) LabelType */
                    ASTLabelType jjtn000 = new ASTLabelType(this, JJTLABELTYPE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) LabelType */
        try {
/*@egen*/
	t=<LABEL>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/{jjtn000.setImage(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

//gcc
void DeclarationSpecifiers() : {/*@bgen(jjtree) DeclarationSpecifiers */
  ASTDeclarationSpecifiers jjtn000 = new ASTDeclarationSpecifiers(this, JJTDECLARATIONSPECIFIERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeclarationSpecifiers */
        try {
/*@egen*/
	(
	  StorageClassSpecifier() 
	  [ LOOKAHEAD(DeclarationSpecifiers())
	        DeclarationSpecifiers()] |
	  TypeSpecifier()  [ LOOKAHEAD(DeclarationSpecifiers())
	        DeclarationSpecifiers() ] |
	  TypeQualifier() [ LOOKAHEAD(DeclarationSpecifiers())
	        DeclarationSpecifiers() ] 
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//GCC
void TypeofDeclarationSpecifier() :{/*@bgen(jjtree) TypeofDeclarationSpecifier */
  ASTTypeofDeclarationSpecifier jjtn000 = new ASTTypeofDeclarationSpecifier(this, JJTTYPEOFDECLARATIONSPECIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeofDeclarationSpecifier */
        try {
/*@egen*/
	<TYPEOF> 
	"(" 
		( LOOKAHEAD(3) TypeName() 
		 | LOOKAHEAD(AssignmentExpression()) AssignmentExpression() 
		)
	")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void StorageClassSpecifier() : {/*@bgen(jjtree) StorageClassSpecifier */
                                ASTStorageClassSpecifier jjtn000 = new ASTStorageClassSpecifier(this, JJTSTORAGECLASSSPECIFIER);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) StorageClassSpecifier */
        try {
/*@egen*/
	( t=<AUTO>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setImage(t.image);} 
	| t=<REGISTER>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ {jjtn000.setImage(t.image);} 
	| t=<STATIC>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {jjtn000.setImage(t.image);} 
	| t=<EXTERN>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {jjtn000.setImage(t.image);} 
	| t=<TYPEDEF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setImage(t.image); 
		pushTypedefParsingStack(Boolean.TRUE,"Encounter a StorageClassSpecifier");
	} )/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//gcc
void TypeSpecifier() : {/*@bgen(jjtree) TypeSpecifier */
  ASTTypeSpecifier jjtn000 = new ASTTypeSpecifier(this, JJTTYPESPECIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeSpecifier */
        try {
/*@egen*/
	(
	  <BOOL>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.setImage("_Bool");} 
	| <VOID>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.setImage("void");}
	| <CHAR>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.setImage("char");}
	| <SHORT>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.setImage("short");}
	| <INT>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {jjtn000.setImage("int");}
	| <LONG>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.setImage("long");}
	| <FLOAT>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.setImage("float");}
	| <DECIMALFLOAT>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {jjtn000.setImage("decimalfloat");}
	| <DOUBLE>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setImage("double");}
	| <SIGNED>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setImage("signed");}
	| <UNSIGNED>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {jjtn000.setImage("unsigned");}
	| StructOrUnionSpecifier() 
	| EnumSpecifier() 
	| LOOKAHEAD( {isType(getToken(1).image) && getToken(2).kind!=CParser_GCCConstants.SEMICOLON							
	  										&& getToken(2).kind!=CParser_GCCConstants.EQUAL } ) TypedefName() 
	| TypeofDeclarationSpecifier()  
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeQualifier() : {/*@bgen(jjtree) TypeQualifier */
                        ASTTypeQualifier jjtn000 = new ASTTypeQualifier(this, JJTTYPEQUALIFIER);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) TypeQualifier */
        try {
/*@egen*/
	( t=<CONST>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ {jjtn000.setImage(t.image);} 
	| t=<VOLATILE>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ {jjtn000.setImage(t.image);} 
	| t=<STATIC>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {jjtn000.setImage(t.image);} //added by qfx 2013-3-22
	| t=<FAR>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.setImage(t.image);} 
	| t=<NEAR>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setImage(t.image);} 
	| t=<COMPLEX>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ {jjtn000.setImage(t.image);} 
	| t=<THREAD>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {jjtn000.setImage(t.image);} 
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//GCC:
void StructOrUnionSpecifier() : {/*@bgen(jjtree) StructOrUnionSpecifier */
                                 ASTStructOrUnionSpecifier jjtn000 = new ASTStructOrUnionSpecifier(this, JJTSTRUCTORUNIONSPECIFIER);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t = null;}
{/*@bgen(jjtree) StructOrUnionSpecifier */
        try {
/*@egen*/
	{
		pushTypedefParsingStack(Boolean.FALSE,"Enter Union&Struct");
	}
	try{
		StructOrUnion() ( LOOKAHEAD(3) [ t=<IDENTIFIER>{jjtn000.setImage(t.image);} ] 
		<LEFTCURLYBRACKETS> 
		{
			structStack.push(Boolean.TRUE);
		}
		try {
			StructDeclarationList() 
		} catch (Exception ex) {
			DeclarationException(ex);
		} finally {
			structStack.pop();
		}
		<RIGHTCURLYBRACKETS> | t=<IDENTIFIER>{jjtn000.setImage(t.image);} )
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
	}finally{
		popTypedefParsingStack("Enter Union&Struct");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StructOrUnion() : {/*@bgen(jjtree) StructOrUnion */
                        ASTStructOrUnion jjtn000 = new ASTStructOrUnion(this, JJTSTRUCTORUNION);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) StructOrUnion */
        try {
/*@egen*/
	( t=<STRUCT>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/{jjtn000.setImage(t.image);} | t=<UNION>/*@bgen(jjtree)*/
                                                            {
                                                              jjtree.closeNodeScope(jjtn000, true);
                                                              jjtc000 = false;
                                                            }
/*@egen*/{jjtn000.setImage(t.image);} )/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//added by zys :gcc:empty struct such as struct s{};
void StructDeclarationList() : {/*@bgen(jjtree) StructDeclarationList */
  ASTStructDeclarationList jjtn000 = new ASTStructDeclarationList(this, JJTSTRUCTDECLARATIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StructDeclarationList */
        try {
/*@egen*/
	(StructDeclaration())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void InitDeclaratorList() : {/*@bgen(jjtree) InitDeclaratorList */
  ASTInitDeclaratorList jjtn000 = new ASTInitDeclaratorList(this, JJTINITDECLARATORLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InitDeclaratorList */
        try {
/*@egen*/
	try{
	InitDeclarator() (<COMMA> InitDeclarator())*
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
	}finally{
		
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void InitDeclarator() : {/*@bgen(jjtree) InitDeclarator */
  ASTInitDeclarator jjtn000 = new ASTInitDeclarator(this, JJTINITDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InitDeclarator */
        try {
/*@egen*/
	Declarator() [ "=" Initializer() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StructDeclaration() : {/*@bgen(jjtree) StructDeclaration */
  ASTStructDeclaration jjtn000 = new ASTStructDeclaration(this, JJTSTRUCTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StructDeclaration */
        try {
/*@egen*/
	try{
	[ SpecifierQualifierList() 
	[StructDeclaratorList()] ]
	<SEMICOLON>
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SpecifierQualifierList() : {/*@bgen(jjtree) SpecifierQualifierList */
  ASTSpecifierQualifierList jjtn000 = new ASTSpecifierQualifierList(this, JJTSPECIFIERQUALIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SpecifierQualifierList */
          try {
/*@egen*/
	  TypeSpecifier() [ LOOKAHEAD(SpecifierQualifierList())
	        SpecifierQualifierList() ]|
	  TypeQualifier() [ LOOKAHEAD(SpecifierQualifierList())
	        SpecifierQualifierList() ]/*@bgen(jjtree)*/
          } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              throw (RuntimeException)jjte000;
            }
            if (jjte000 instanceof ParseException) {
              throw (ParseException)jjte000;
            }
            throw (Error)jjte000;
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/
}

void StructDeclaratorList() : {/*@bgen(jjtree) StructDeclaratorList */
  ASTStructDeclaratorList jjtn000 = new ASTStructDeclaratorList(this, JJTSTRUCTDECLARATORLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StructDeclaratorList */
        try {
/*@egen*/
	StructDeclarator() ( <COMMA> StructDeclarator() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StructDeclarator() : {/*@bgen(jjtree) StructDeclarator */
  ASTStructDeclarator jjtn000 = new ASTStructDeclarator(this, JJTSTRUCTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StructDeclarator */
        try {
/*@egen*/
	LOOKAHEAD([Declarator()] ":")
	[ Declarator() ] ":" ConstantExpression() 
	|Declarator()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//GCC
void EnumSpecifier() : {/*@bgen(jjtree) EnumSpecifier */
                        ASTEnumSpecifier jjtn000 = new ASTEnumSpecifier(this, JJTENUMSPECIFIER);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t = null;}
{/*@bgen(jjtree) EnumSpecifier */
        try {
/*@egen*/
	<ENUM> ( LOOKAHEAD(3) [ t=<IDENTIFIER>{jjtn000.setImage(t.image);}  ] <LEFTCURLYBRACKETS> EnumeratorList() [<COMMA>] <RIGHTCURLYBRACKETS> | t=<IDENTIFIER>/*@bgen(jjtree)*/
                                                                                                                                                                  {
                                                                                                                                                                    jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                    jjtc000 = false;
                                                                                                                                                                  }
/*@egen*/{jjtn000.setImage(t.image);} )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//gcc : 	enum weekday{}; 
void EnumeratorList() : {/*@bgen(jjtree) EnumeratorList */
  ASTEnumeratorList jjtn000 = new ASTEnumeratorList(this, JJTENUMERATORLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EnumeratorList */
        try {
/*@egen*/
	[Enumerator()] (LOOKAHEAD(2)  <COMMA> Enumerator())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Enumerator() : {/*@bgen(jjtree) Enumerator */
                     ASTEnumerator jjtn000 = new ASTEnumerator(this, JJTENUMERATOR);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t = null;}
{/*@bgen(jjtree) Enumerator */
        try {
/*@egen*/
	t=<IDENTIFIER>{jjtn000.setImage(t.image);} [ "=" ConstantExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

//GCC: void* __attribute__ ((pure)) fun() __attribute__((hot));
void Declarator() : {/*@bgen(jjtree) Declarator */
  ASTDeclarator jjtn000 = new ASTDeclarator(this, JJTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declarator */
        try {
/*@egen*/
	[ Pointer() ] 
	DirectDeclarator()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DirectDeclarator() : {/*@bgen(jjtree) DirectDeclarator */
                            ASTDirectDeclarator jjtn000 = new ASTDirectDeclarator(this, JJTDIRECTDECLARATOR);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;boolean flag=false;}
{/*@bgen(jjtree) DirectDeclarator */
        try {
/*@egen*/
	(

		( t = <IDENTIFIER>

		{ 
			jjtn000.setImage(t.image);
			if(!(typedefParsingStack.empty()) && ((Boolean)typedefParsingStack.peek()).booleanValue()){
				addType(t.image);
				jjtn000.setIstypedef(true);
	  		}
		}
		| "(" Declarator(){flag=true;jjtn000.setOperatorTypeAndFlag("",flag);flag=false;} ")" 
		)
		{ typedefParsingStack.push( Boolean.FALSE ); }
		//modified by qfx 2013-3-22:  static, const, volatile
		( "[" [TypeQualifier()][ ConstantExpression(){flag=true;} ] "]"{jjtn000.setOperatorTypeAndFlag("[",flag);flag=false;}  |
	    	  LOOKAHEAD(3) "(" ParameterTypeList(){flag=true;} ")"{jjtn000.setOperatorTypeAndFlag("(",flag);flag=false;}  |
	    	  "(" [ IdentifierList(){flag=true;} ] ")" {jjtn000.setOperatorTypeAndFlag("(",flag);flag=false;} 
	    	)*/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
	 	{ typedefParsingStack.pop(); }   
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Pointer() : {/*@bgen(jjtree) Pointer */
  ASTPointer jjtn000 = new ASTPointer(this, JJTPOINTER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Pointer */
        try {
/*@egen*/
	"*" [ TypeQualifierList() ] [ Pointer() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeQualifierList() : {/*@bgen(jjtree) TypeQualifierList */
  ASTTypeQualifierList jjtn000 = new ASTTypeQualifierList(this, JJTTYPEQUALIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeQualifierList */
        try {
/*@egen*/
	(TypeQualifier())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ParameterTypeList() : {/*@bgen(jjtree) ParameterTypeList */
  ASTParameterTypeList jjtn000 = new ASTParameterTypeList(this, JJTPARAMETERTYPELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterTypeList */
        try {
/*@egen*/
	{ 
		pushTypedefParsingStack(Boolean.FALSE,"Enter ParameterTypeList");
	}
	try{
	ParameterList() [<COMMA> "..." {jjtn000.setVararg(true);}]
	}catch(Exception e){
		DeclarationException(e);
	}finally{
		popTypedefParsingStack("Exit ParameterTypeList");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ParameterList() : {/*@bgen(jjtree) ParameterList */
  ASTParameterList jjtn000 = new ASTParameterList(this, JJTPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterList */
        try {
/*@egen*/
	ParameterDeclaration() (LOOKAHEAD(2) <COMMA> ParameterDeclaration())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ParameterDeclaration() : {/*@bgen(jjtree) ParameterDeclaration */
  ASTParameterDeclaration jjtn000 = new ASTParameterDeclaration(this, JJTPARAMETERDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterDeclaration */
        try {
/*@egen*/
	DeclarationSpecifiers() ( LOOKAHEAD(Declarator()) Declarator() | [ AbstractDeclarator() ] )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void IdentifierList() : {/*@bgen(jjtree) IdentifierList */
                         ASTIdentifierList jjtn000 = new ASTIdentifierList(this, JJTIDENTIFIERLIST);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) IdentifierList */
        try {
/*@egen*/
	t=<IDENTIFIER>{jjtn000.addIndentifier(t.image);} (<COMMA> t=<IDENTIFIER>{jjtn000.addIndentifier(t.image);})*/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//GCC:int a[][2][4] = { [2 ... 4][0 ... 1][2 ... 3] = 1, [2] = 2, [2][0][2] = 3 };
//struct A a = (struct A) { .j = 6, .k[2] = 12 };
//struct M n[] = { [0 ... 5].O[1 ... 2].K[0 ... 1] = 4, 5, 6, 7 };
//struct M o[] = { [0 ... 5].O = { [1 ... 2].K[0 ... 1] = 4 },[5].O[2].K[2] = 5, 6, 7 };
void Initializer() : {/*@bgen(jjtree) Initializer */
  ASTInitializer jjtn000 = new ASTInitializer(this, JJTINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Initializer */
        try {
/*@egen*/
	( 
	LOOKAHEAD("[" ConstantExpression() "]") ("[" ConstantExpression() "]")+ ["." <IDENTIFIER>]  /*("[" ConstantExpression() "]")**/ ["="] ConstantExpression() |
	LOOKAHEAD("[" ConstantExpression() "...") ("[" ConstantExpression() "..." ConstantExpression() "]")+ ["="] ConstantExpression() |
	LOOKAHEAD("." PostfixExpression() "=" ) "." PostfixExpression() "=" AssignmentExpression() |
	LOOKAHEAD(<IDENTIFIER> ":") <IDENTIFIER> ":" AssignmentExpression() |
	  LOOKAHEAD(AssignmentExpression()) AssignmentExpression() |
	  <LEFTCURLYBRACKETS> InitializerList() [<COMMA>] <RIGHTCURLYBRACKETS> )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void InitializerList() : {/*@bgen(jjtree) InitializerList */
  ASTInitializerList jjtn000 = new ASTInitializerList(this, JJTINITIALIZERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InitializerList */
        try {
/*@egen*/
	[Initializer()] (LOOKAHEAD(2) <COMMA> Initializer())*(LOOKAHEAD(2)<COMMA>)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeName() : {/*@bgen(jjtree) TypeName */
  ASTTypeName jjtn000 = new ASTTypeName(this, JJTTYPENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeName */
        try {
/*@egen*/
	SpecifierQualifierList() ([ AbstractDeclarator() ])/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

void AbstractDeclarator() : {/*@bgen(jjtree) AbstractDeclarator */
  ASTAbstractDeclarator jjtn000 = new ASTAbstractDeclarator(this, JJTABSTRACTDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AbstractDeclarator */
        try {
/*@egen*/
	LOOKAHEAD( DirectAbstractDeclarator()Pointer())DirectAbstractDeclarator()Pointer()|
	LOOKAHEAD([Pointer()] DirectAbstractDeclarator())
	[Pointer()] DirectAbstractDeclarator() |
	Pointer()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
	
	 
}

void DirectAbstractDeclarator() : {/*@bgen(jjtree) DirectAbstractDeclarator */
                                   ASTDirectAbstractDeclarator jjtn000 = new ASTDirectAbstractDeclarator(this, JJTDIRECTABSTRACTDECLARATOR);
                                   boolean jjtc000 = true;
                                   jjtree.openNodeScope(jjtn000);
/*@egen*/boolean flag=false;}
{/*@bgen(jjtree) DirectAbstractDeclarator */
        try {
/*@egen*/
	( LOOKAHEAD(2) "(" AbstractDeclarator(){flag=true;} ")"{jjtn000.setOperatorTypeAndFlag("",flag);flag=false;} |
	               "[" [ConstantExpression(){flag=true;}] "]"{jjtn000.setOperatorTypeAndFlag("[",flag);flag=false;} |
	               "(" [ParameterTypeList(){flag=true;}] ")"{jjtn000.setOperatorTypeAndFlag("(",flag);flag=false;} 
	)

	( "[" [ ConstantExpression() {flag=true;}] "]"{jjtn000.setOperatorTypeAndFlag("[",flag);flag=false;} | 
	  "(" [ ParameterTypeList() {flag=true;}] ")"{jjtn000.setOperatorTypeAndFlag("(",flag);flag=false;} 
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void TypedefName() : {/*@bgen(jjtree) TypedefName */
                      ASTTypedefName jjtn000 = new ASTTypedefName(this, JJTTYPEDEFNAME);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) TypedefName */
        try {
/*@egen*/
	t=<IDENTIFIER>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/{jjtn000.setImage(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//added by zys:gcc 5.26-Mixed Declarations and Codes
//to make Statement() can include Declaration()?
void Statement() : {/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(this, JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
        try {
/*@egen*/
	try{
	( 
	  LOOKAHEAD(DeclarationSpecifiers() Declarator() [ DeclarationList() ] "{" ) 
	  NestedFunctionDefinition() | 
	  LOOKAHEAD(NestedFunctionDeclaration()) NestedFunctionDeclaration() |
	  LOOKAHEAD(DeclarationSpecifiers() FunctionDeclaration()) FunctionDeclaration() | 
	  LOOKAHEAD(Declaration()) Declaration() |
	  LOOKAHEAD(2) LabeledStatement() |
	  LOOKAHEAD(ExpressionStatement()) ExpressionStatement() |
	  CompoundStatement() |
	  SelectionStatement() |
	  IterationStatement() |
	  JumpStatement() )
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
		/*( LOOKAHEAD(2) LabeledStatement() |
	  ExpressionStatement() |
	  CompoundStatement() |
	  SelectionStatement() |
	  IterationStatement() |
	  JumpStatement() )*/
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//GCC:	case 1 ... 9:
void LabeledStatement() : {/*@bgen(jjtree) LabeledStatement */
                           ASTLabeledStatement jjtn000 = new ASTLabeledStatement(this, JJTLABELEDSTATEMENT);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) LabeledStatement */
        try {
/*@egen*/
	( /*LOOKAHEAD(2)*/ t=<IDENTIFIER>{jjtn000.setImage(t.image);} ":" Statement() |
	  LOOKAHEAD(<CASE> ConstantExpression() "...") t=<CASE>{jjtn000.setImage(t.image);} ConstantExpression() "..." ConstantExpression() ":" Statement() |
	  t=<CASE>{jjtn000.setImage(t.image);} ConstantExpression() ":" Statement() |
	  t=<DFLT>{jjtn000.setImage(t.image);} ":" Statement() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExpressionStatement() : {/*@bgen(jjtree) ExpressionStatement */
  ASTExpressionStatement jjtn000 = new ASTExpressionStatement(this, JJTEXPRESSIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExpressionStatement */
        try {
/*@egen*/
	[ Expression() ] <SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//GCC: 5.2- Locally Declared Labels
////added by zys:gcc 5.26-Mixed Declarations and Codes
void CompoundStatement() : {/*@bgen(jjtree) CompoundStatement */
  ASTCompoundStatement jjtn000 = new ASTCompoundStatement(this, JJTCOMPOUNDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompoundStatement */
        try {
/*@egen*/
	<LEFTCURLYBRACKETS> 
	(	[ LOOKAHEAD(LabelDeclarationList()) LabelDeclarationList() ]
	    [ LOOKAHEAD(StatementList()) StatementList() ])
	<RIGHTCURLYBRACKETS>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StatementList() : {/*@bgen(jjtree) StatementList */
  ASTStatementList jjtn000 = new ASTStatementList(this, JJTSTATEMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StatementList */
        try {
/*@egen*/	
	try{
	(Statement())+
	}catch(ParseException e){
		error_skipto(SEMICOLON,e);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//GCC
void SelectionStatement() : {/*@bgen(jjtree) SelectionStatement */
                             ASTSelectionStatement jjtn000 = new ASTSelectionStatement(this, JJTSELECTIONSTATEMENT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) SelectionStatement */
        try {
/*@egen*/
	( t=<IF>{jjtn000.setImage(t.image);} "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ] |
	  t=<SWITCH>{jjtn000.setImage(t.image);} "(" Expression() ")" Statement() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void IterationStatement() : {/*@bgen(jjtree) IterationStatement */
                             ASTIterationStatement jjtn000 = new ASTIterationStatement(this, JJTITERATIONSTATEMENT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) IterationStatement */
        try {
/*@egen*/
	( t=<WHILE>{jjtn000.setImage(t.image);} "(" Expression() ")" Statement() |
	  t=<DO>{jjtn000.setImage(t.image);} Statement() <WHILE> "(" Expression() ")" <SEMICOLON> |
	  t=<FOR>{jjtn000.setImage(t.image);} "("
	 ( Declaration() {jjtn000.forChild[0]=true;} | ( [Expression() {jjtn000.forChild[0]=true;} ] <SEMICOLON>)) 	 
	  [ Expression(){jjtn000.forChild[1]=true;} ] <SEMICOLON> [ Expression(){jjtn000.forChild[2]=true;} ] ")" Statement() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



////added by zys:gcc 5.3 Labels as Values
//// label a; a:....;void *ptr=&&a; goto *ptr;
void JumpStatement() : {/*@bgen(jjtree) JumpStatement */
                        ASTJumpStatement jjtn000 = new ASTJumpStatement(this, JJTJUMPSTATEMENT);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t,l;}
{/*@bgen(jjtree) JumpStatement */
        try {
/*@egen*/
	( LOOKAHEAD(<GOTO> <IDENTIFIER>) 
	t=<GOTO>{jjtn000.setImage(t.image);} l=<IDENTIFIER>{jjtn000.setLabel(l.image);} <SEMICOLON> |
	LOOKAHEAD(<GOTO> "*") 
	t=<GOTO>{jjtn000.setImage(t.image);} UnaryExpression() <SEMICOLON>|
	t=<CONTINUE>{jjtn000.setImage(t.image);} <SEMICOLON> |
	t=<BREAK>{jjtn000.setImage(t.image);} <SEMICOLON> |
	t=<RETURN>{jjtn000.setImage(t.image);} [ Expression() ] <SEMICOLON> )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Expression() : {/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(this, JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	AssignmentExpression() ( <COMMA> AssignmentExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//gcc: (int)x=3
void AssignmentExpression() : {/*@bgen(jjtree) AssignmentExpression */
  ASTAssignmentExpression jjtn000 = new ASTAssignmentExpression(this, JJTASSIGNMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignmentExpression */
          try {
/*@egen*/
	  LOOKAHEAD(UnaryExpression() AssignmentOperator()) UnaryExpression() AssignmentOperator() AssignmentExpression() |
	  LOOKAHEAD(CastExpression() AssignmentOperator()) 
	  CastExpression() AssignmentOperator() AssignmentExpression()|
	  ConditionalExpression()
	 |	  LOOKAHEAD(StructOrUnionSpecifier()<COMMA>UnaryExpression())StructOrUnionSpecifier()<COMMA>UnaryExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              throw (RuntimeException)jjte000;
            }
            if (jjte000 instanceof ParseException) {
              throw (ParseException)jjte000;
            }
            throw (Error)jjte000;
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/
}

void AssignmentOperator() : {/*@bgen(jjtree) AssignmentOperator */
  ASTAssignmentOperator jjtn000 = new ASTAssignmentOperator(this, JJTASSIGNMENTOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignmentOperator */
        try {
/*@egen*/
	( "="/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/{jjtn000.setOperatorType("=");} | "*="/*@bgen(jjtree)*/
                                                    {
                                                      jjtree.closeNodeScope(jjtn000, true);
                                                      jjtc000 = false;
                                                    }
/*@egen*/ {jjtn000.setOperatorType("*=");} | "/="/*@bgen(jjtree)*/
                                                                                            {
                                                                                              jjtree.closeNodeScope(jjtn000, true);
                                                                                              jjtc000 = false;
                                                                                            }
/*@egen*/ {jjtn000.setOperatorType("/=");}  | "%="/*@bgen(jjtree)*/
                                                                                                                                     {
                                                                                                                                       jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                       jjtc000 = false;
                                                                                                                                     }
/*@egen*/ {jjtn000.setOperatorType("%=");} 
	| "+="/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/  {jjtn000.setOperatorType("+=");} | "-="/*@bgen(jjtree)*/
                                                         {
                                                           jjtree.closeNodeScope(jjtn000, true);
                                                           jjtc000 = false;
                                                         }
/*@egen*/  {jjtn000.setOperatorType("-=");} | "<<="/*@bgen(jjtree)*/
                                                                                                  {
                                                                                                    jjtree.closeNodeScope(jjtn000, true);
                                                                                                    jjtc000 = false;
                                                                                                  }
/*@egen*/ {jjtn000.setOperatorType("<<=");}  | ">>="/*@bgen(jjtree)*/
                                                                                                                                              {
                                                                                                                                                jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                jjtc000 = false;
                                                                                                                                              }
/*@egen*/  {jjtn000.setOperatorType(">>=");} 
	| "&="/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/  {jjtn000.setOperatorType("&=");} | "^="/*@bgen(jjtree)*/
                                                        {
                                                          jjtree.closeNodeScope(jjtn000, true);
                                                          jjtc000 = false;
                                                        }
/*@egen*/ {jjtn000.setOperatorType("^=");}  | "|="/*@bgen(jjtree)*/
                                                                                                 {
                                                                                                   jjtree.closeNodeScope(jjtn000, true);
                                                                                                   jjtc000 = false;
                                                                                                 }
/*@egen*/ {jjtn000.setOperatorType("|=");}  )/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

////added by zys:GCC 5.7 Conditionals with Omitted Operands
////x?:y ==>x?x:y
void ConditionalExpression()                           : {/*@bgen(jjtree) #ConditionalExpression(> 1) */
  ASTConditionalExpression jjtn000 = new ASTConditionalExpression(this, JJTCONDITIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #ConditionalExpression(> 1) */
        try {
/*@egen*/
	LogicalORExpression() [ "?" [Expression()] ":" ConditionalExpression() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void ConstantExpression() : {/*@bgen(jjtree) ConstantExpression */
  ASTConstantExpression jjtn000 = new ASTConstantExpression(this, JJTCONSTANTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConstantExpression */
        try {
/*@egen*/
	ConditionalExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LogicalORExpression()                         : {/*@bgen(jjtree) #LogicalORExpression(> 1) */
  ASTLogicalORExpression jjtn000 = new ASTLogicalORExpression(this, JJTLOGICALOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #LogicalORExpression(> 1) */
        try {
/*@egen*/
	LogicalANDExpression() ( "||"  {jjtn000.setOperatorType("||");}LogicalANDExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void LogicalANDExpression()                          : {/*@bgen(jjtree) #LogicalANDExpression(> 1) */
  ASTLogicalANDExpression jjtn000 = new ASTLogicalANDExpression(this, JJTLOGICALANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #LogicalANDExpression(> 1) */
        try {
/*@egen*/
	InclusiveORExpression() ( "&&"{jjtn000.setOperatorType("&&");} InclusiveORExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void InclusiveORExpression()                           : {/*@bgen(jjtree) #InclusiveORExpression(> 1) */
  ASTInclusiveORExpression jjtn000 = new ASTInclusiveORExpression(this, JJTINCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #InclusiveORExpression(> 1) */
        try {
/*@egen*/
	ExclusiveORExpression() ( "|" {jjtn000.setOperatorType("|");} ExclusiveORExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void ExclusiveORExpression()                           : {/*@bgen(jjtree) #ExclusiveORExpression(> 1) */
  ASTExclusiveORExpression jjtn000 = new ASTExclusiveORExpression(this, JJTEXCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #ExclusiveORExpression(> 1) */
        try {
/*@egen*/
	ANDExpression() ( "^"  {jjtn000.setOperatorType("^");}ANDExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void ANDExpression()                   : {/*@bgen(jjtree) #ANDExpression(> 1) */
  ASTANDExpression jjtn000 = new ASTANDExpression(this, JJTANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #ANDExpression(> 1) */
        try {
/*@egen*/
	EqualityExpression() ( LOOKAHEAD(2) "&"{jjtn000.setOperatorType("&");} EqualityExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void EqualityExpression()                        : {/*@bgen(jjtree) #EqualityExpression(> 1) */
  ASTEqualityExpression jjtn000 = new ASTEqualityExpression(this, JJTEQUALITYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #EqualityExpression(> 1) */
        try {
/*@egen*/
	RelationalExpression() ( ( "==" {jjtn000.setOperatorType("==");}| "!=" {jjtn000.setOperatorType("!=");} ) RelationalExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void RelationalExpression()                          : {/*@bgen(jjtree) #RelationalExpression(> 1) */
  ASTRelationalExpression jjtn000 = new ASTRelationalExpression(this, JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #RelationalExpression(> 1) */
        try {
/*@egen*/
	ShiftExpression() ( LOOKAHEAD(2) ( "<" {jjtn000.setOperatorType("<");}  | ">" {jjtn000.setOperatorType(">");}  | "<="  {jjtn000.setOperatorType("<=");} | ">=" {jjtn000.setOperatorType(">=");}  )  ShiftExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void ShiftExpression()                     : {/*@bgen(jjtree) #ShiftExpression(> 1) */
  ASTShiftExpression jjtn000 = new ASTShiftExpression(this, JJTSHIFTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #ShiftExpression(> 1) */
        try {
/*@egen*/
	AdditiveExpression() ( ( "<<" {jjtn000.setOperatorType("<<");}  | ">>"  {jjtn000.setOperatorType(">>");} )  AdditiveExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void AdditiveExpression()                        : {/*@bgen(jjtree) #AdditiveExpression(> 1) */
  ASTAdditiveExpression jjtn000 = new ASTAdditiveExpression(this, JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #AdditiveExpression(> 1) */
        try {
/*@egen*/
	MultiplicativeExpression() (LOOKAHEAD(2) ( "+" {jjtn000.setOperatorType("+");}  | "-"  {jjtn000.setOperatorType("-");} ) MultiplicativeExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

void MultiplicativeExpression()                              : {/*@bgen(jjtree) #MultiplicativeExpression(> 1) */
  ASTMultiplicativeExpression jjtn000 = new ASTMultiplicativeExpression(this, JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #MultiplicativeExpression(> 1) */
        try {
/*@egen*/
	CastExpression()  (LOOKAHEAD(2) ( "*"  {jjtn000.setOperatorType("*");} | "/" {jjtn000.setOperatorType("/");}  | "%" {jjtn000.setOperatorType("%");}  ) CastExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}

//gcc:	struct foo {int a; char b[2];} structure;
//		structure = ((struct foo) {x + y, \u2019a\u2019, 0});
void CastExpression()                    : {/*@bgen(jjtree) #CastExpression(> 1) */
  ASTCastExpression jjtn000 = new ASTCastExpression(this, JJTCASTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #CastExpression(> 1) */
        try {
/*@egen*/
	( LOOKAHEAD("(" TypeName() ")" CastExpression() ) "(" TypeName() ")" CastExpression() |
	  UnaryExpression() 
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/ 
}

//gcc: alignof
void UnaryExpression() : {/*@bgen(jjtree) UnaryExpression */
                          ASTUnaryExpression jjtn000 = new ASTUnaryExpression(this, JJTUNARYEXPRESSION);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) UnaryExpression */
        try {
/*@egen*/
	( 
	  LOOKAHEAD(3) PostfixExpression() |
	  "++"  {jjtn000.setOperatorType("++");} UnaryExpression() |
	  "--" {jjtn000.setOperatorType("--");}  UnaryExpression() |
	  UnaryOperator() CastExpression() |
	  t=<SIZEOF>{jjtn000.setImage(t.image);} ( LOOKAHEAD(UnaryExpression()) UnaryExpression() | "(" TypeName() ")" ) |
	  t=<ALIGNOF>{jjtn000.setImage(t.image);} ( LOOKAHEAD(UnaryExpression() ) UnaryExpression() | "(" TypeName() ")" ) 		 
	 | t=<IMAG>{jjtn000.setImage(t.image);} ( LOOKAHEAD(UnaryExpression() ) UnaryExpression() | "(" TypeName() ")" )
	 | t=<REAL>{jjtn000.setImage(t.image);} ( LOOKAHEAD(UnaryExpression() ) UnaryExpression() | "(" TypeName() ")" )
	 | LOOKAHEAD("{" InitializerList() "}") "{" InitializerList() "}"
	 )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

////added by zys:gcc 5.3 Labels as Values
//// label a; a:....;void *ptr=&&a; goto *ptr;
void UnaryOperator() : {/*@bgen(jjtree) UnaryOperator */
  ASTUnaryOperator jjtn000 = new ASTUnaryOperator(this, JJTUNARYOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnaryOperator */
        try {
/*@egen*/
	( "&&"/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.setOperatorType("&&");} | "&"/*@bgen(jjtree)*/
                                                      {
                                                        jjtree.closeNodeScope(jjtn000, true);
                                                        jjtc000 = false;
                                                      }
/*@egen*/ {jjtn000.setOperatorType("&");}  | "*"/*@bgen(jjtree)*/
                                                                                             {
                                                                                               jjtree.closeNodeScope(jjtn000, true);
                                                                                               jjtc000 = false;
                                                                                             }
/*@egen*/ {jjtn000.setOperatorType("*");}  | "+"/*@bgen(jjtree)*/
                                                                                                                                    {
                                                                                                                                      jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                      jjtc000 = false;
                                                                                                                                    }
/*@egen*/ {jjtn000.setOperatorType("+");}  | "-"/*@bgen(jjtree)*/
                                                                                                                                                                           {
                                                                                                                                                                             jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                             jjtc000 = false;
                                                                                                                                                                           }
/*@egen*/ {jjtn000.setOperatorType("-");}  | "~"/*@bgen(jjtree)*/
                                                                                                                                                                                                                  {
                                                                                                                                                                                                                    jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                    jjtc000 = false;
                                                                                                                                                                                                                  }
/*@egen*/ {jjtn000.setOperatorType("~");}  | "!"/*@bgen(jjtree)*/
                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                            jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                                            jjtc000 = false;
                                                                                                                                                                                                                                                          }
/*@egen*/  {jjtn000.setOperatorType("!");} )/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FieldId():{/*@bgen(jjtree) FieldId */
                ASTFieldId jjtn000 = new ASTFieldId(this, JJTFIELDID);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) FieldId */
        try {
/*@egen*/
	t=<IDENTIFIER>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/{jjtn000.setImage(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

//gcc:	typeof (*(A));
void PostfixExpression() : {/*@bgen(jjtree) PostfixExpression */
                            ASTPostfixExpression jjtn000 = new ASTPostfixExpression(this, JJTPOSTFIXEXPRESSION);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/boolean flag=false;}
{/*@bgen(jjtree) PostfixExpression */
        try {
/*@egen*/
	PrimaryExpression() ( "[" Expression() {jjtn000.setOperatorTypeAndFlag("[",true);}"]" |
	                      "(" [ LOOKAHEAD(ArgumentExpressionList() ) ArgumentExpressionList() {flag=true;}] {jjtn000.setOperatorTypeAndFlag("(",flag);flag=false;}")" |
	  					  "."  FieldId() {jjtn000.setOperatorTypeAndFlag(".",true);}|
	  					  "->" FieldId() {jjtn000.setOperatorTypeAndFlag("->",true);}|
	  					  "++"  {jjtn000.setOperatorTypeAndFlag("++",false);} |
	  					  "--"  {jjtn000.setOperatorTypeAndFlag("--",false);} )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//GCC: add statement expression such as int i=({int j;j++;int k;j*k;});
void PrimaryExpression() : {/*@bgen(jjtree) PrimaryExpression */
                            ASTPrimaryExpression jjtn000 = new ASTPrimaryExpression(this, JJTPRIMARYEXPRESSION);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) PrimaryExpression */
        try {
/*@egen*/
	( t=<IDENTIFIER>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {jjtn000.setImage(t.image);} 
	| Constant() 
	| LOOKAHEAD( "(" Expression() ) "(" Expression() ")"
	| LOOKAHEAD("(" CompoundStatement()) "(" CompoundStatement() ")"
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ArgumentExpressionList() : {/*@bgen(jjtree) ArgumentExpressionList */
  ASTArgumentExpressionList jjtn000 = new ASTArgumentExpressionList(this, JJTARGUMENTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArgumentExpressionList */
        try {
/*@egen*/
	AssignmentExpression() ( <COMMA> AssignmentExpression() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//gcc
void Constant() : {/*@bgen(jjtree) Constant */
                   ASTConstant jjtn000 = new ASTConstant(this, JJTCONSTANT);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Constant */
        try {
/*@egen*/
	(
		t=<INTEGER_LITERAL> 
	| t=<BINARY_LITERAL>  //added by qfx,GCC 
	|	t=<COMPLEX_LITERAL>
 	|	t=<FLOATING_POINT_LITERAL>
 	|	t=<CHARACTER_LITERAL>
 	|	(t=<STRING_LITERAL>)+
 	|	t=<FUNC>	//gcc : __func__
 	)/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {jjtn000.setImage(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
