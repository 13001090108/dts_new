/* Generated By:JJTree&JavaCC: Do not edit this line. CParser.java */
package softtest.ast.c;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Stack;

import softtest.ast.c.Token;
import softtest.ast.gccparser.c.*;
import softtest.ast.keilparser.c.*;

public abstract class CParser
{
	private static String srcType = "gcc";

	public static void setType(String type)
	{
		srcType = type;
	}

	public static String getType()
	{
		return srcType;
	}

	private static CParser parser = null;
	public static CParser getParser(CharStream stream)
	{
		if (srcType.equalsIgnoreCase("gcc"))
		{
			parser = new CParser_GCC(stream);
		} else if (srcType.equalsIgnoreCase("keil"))
		{
			parser = new CParser_Keil(stream);
		}
		return parser;
	}
	
	/** Current token. */
	public Token token;

	protected JJTCParserState jjtree = new JJTCParserState();
	protected ArrayList errorMsg = new ArrayList();
	public boolean isError()
	{
		return errorMsg.size() != 0;
	}

	public ArrayList getErrorMsg()
	{
		return errorMsg;
	}

	// Hastable for storing typedef types
	public Set types = new HashSet();

	// Stack for determining when the parser
	// is parsing a typdef definition.
	public Stack typedefParsingStack = new Stack();
	
	public void pushTypedefParsingStack(Object o, String reason)
	{
		typedefParsingStack.push(o);
		// System.out.println("Push in:"+o+" "+reason+" in
		// Line:"+jj_nt.beginLine+" size:"+typedefParsingStack.size());
	}
	public void popTypedefParsingStack(String reason)
	{
		Object o = typedefParsingStack.pop();
		// System.out.println("Pop out:"+o+" "+reason+" in
		// Line:"+jj_nt.beginLine+" size:"+typedefParsingStack.size());
	}
	
	public Stack structStack = new Stack();

	// Returns true if the given string is
	// a typedef type.
	public boolean isType(String type)
	{
		return types.contains(type);
	}

	// Add a typedef type to those already defined
	public void addType(String type)
	{
		types.add(type);
	}

	// Prints out all the types used in parsing the c source
	public void printTypes()
	{
		String[] strs = new String[types.size()];
		int j = 0;
		for (Iterator i = types.iterator(); i.hasNext();)
		{
			strs[j++] = (String) (i.next());
		}
		Arrays.sort(strs);
		for (int i = 0; i < strs.length; i++)
		{
			System.out.println(strs[i]);
		}
	}

	public abstract ASTTranslationUnit TranslationUnit() throws ParseException;
	public abstract ASTTranslationUnit createAST(java.io.StringReader input);
	public abstract Token getToken(int index);
	
	//wavericq-2012-05-17
	Stack<Node> decls = new Stack<Node>();
	Stack<Boolean> gottenTypeSpecs = new Stack<Boolean>();
	
	public void enterDecl(Node node)
	{
		decls.push(node);
		gottenTypeSpecs.push(Boolean.FALSE);
	}
	
	public void exitDecl(Node node)
	{
		Node decl = decls.peek();
		if(decl == node)
		{
			decls.pop();
			gottenTypeSpecs.pop();
		}
	}
	
	public void setGottenTypeSpec(boolean flag)
	{
//		if(!gottenTypeSpecs.empty())
//		{
//			gottenTypeSpecs.pop();
//		}
//		gottenTypeSpecs.push(flag);
		
		if(!decls.empty() && gottenTypeSpecs.size() == decls.size())
		{
			gottenTypeSpecs.pop();
			gottenTypeSpecs.push(flag);
		}
	}
	
	public boolean hasGottenTypeSpec()
	{
		boolean gotten = false;
		if(!gottenTypeSpecs.empty())
		{
			gotten = gottenTypeSpecs.peek();
		}
		return  gotten;
	}
	//end
}
