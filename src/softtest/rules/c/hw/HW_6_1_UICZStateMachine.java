package softtest.rules.c.hw;


import java.util.LinkedList;
import java.util.List;
import softtest.ast.c.ASTConstant;
import softtest.ast.c.ASTRelationalExpression;
import softtest.ast.c.AbstractExpression;
import softtest.ast.c.SimpleNode;
import softtest.domain.c.analysis.ExpressionValueVisitor;
import softtest.domain.c.analysis.ExpressionVistorData;
import softtest.domain.c.interval.Domain;
import softtest.domain.c.interval.IntegerDomain;
import softtest.domain.c.symbolic.Expression;
import softtest.fsm.c.FSMMachine;
import softtest.fsm.c.FSMMachineInstance;
import softtest.rules.c.StateMachineUtils;
import softtest.symboltable.c.*;
import softtest.symboltable.c.Type.*;

/**
 * <p>
 * UICZ - Unsigned integer compare with zero<br>
 * 无符号整数判断>0造成无限循环.
 * </p>
 */
public class HW_6_1_UICZStateMachine {

	/**
	 * <p>
	 * Created SVL state machine instances for the specific function.<br>
	 * It's called by reflection.
	 * </p>
	 * 
	 * @param node
	 *            the ast node of the function, it's FunctionDefinition in
	 *            default, TranslationUnit when Scop="File" was used in xml
	 * @param fsm
	 *            the finite state machine object generated by parsing the xml
	 *            fsm descriptor, it's the template of the fsm instance
	 * @return the list of finite state machine instance
	 */
	public static List<FSMMachineInstance> createUICZStateMachines(
            SimpleNode node, FSMMachine fsm) {

            // hold the result
            List<FSMMachineInstance> list = new LinkedList<FSMMachineInstance>();
            // find all outer loop
            String xpath = ".//IterationStatement/Expression//RelationalExpression";
            List<SimpleNode> evaluationResults = StateMachineUtils
                    .getEvaluationResults(node, xpath);
            ASTRelationalExpression relationNode = null;
            for (SimpleNode snode : evaluationResults) {
            	relationNode = (ASTRelationalExpression) snode;
            	if(relationNode.getOperators() == null)
            		continue;
            	if(relationNode.getOperators().equals(">=")){            		
            		if(relationNode.jjtGetChild(0) != null && relationNode.jjtGetChild(1) != null){
            			if(relationNode.jjtGetChild(0) instanceof AbstractExpression && relationNode.jjtGetChild(1) instanceof AbstractExpression ){
		            		AbstractExpression left = (AbstractExpression)relationNode.jjtGetChild(0);
			            	VariableNameDeclaration var = left.getVariableNameDeclaration();
			            	CType type = left.getType();
			            	if(isUnsigned(type)){			            		
			            			AbstractExpression right = (AbstractExpression)relationNode.jjtGetChild(1);
				            		if(isZero(right)){
				            			addFSM(list, relationNode, fsm, var);
				            		}
			            	}
            			}
            		}
            	}
            }
            return list;
        }

    private static void addFSM(List<FSMMachineInstance> list, SimpleNode node,
        FSMMachine fsm, VariableNameDeclaration varDecl) {
        FSMMachineInstance fsminstance = fsm.creatInstance();
        fsminstance.setRelatedASTNode(node);
        fsminstance.setRelatedVariable(varDecl);
        fsminstance.setReleatedVexNode(node.getCurrentVexNode());
        fsminstance.setDesp("在第" + node.getBeginLine() + "行循环中出现无符号数判断是否大于等于0，会造成无限循环。");
        list.add(fsminstance);
    }

	private static boolean isUnsigned (CType type){
    	if (!(type instanceof CType_BaseType)) {
    		if(!((type = type.getNormalType()) instanceof CType_BaseType))
    			return false;
        }
        if(type == CType_BaseType.uCharType 
        		|| type == CType_BaseType.uIntType 
        		|| type == CType_BaseType.uLongLongType 
        		|| type == CType_BaseType.uLongType
        		|| type == CType_BaseType.uShortType ){
        	return true;
        	}
        	else return false;
         }
	private static boolean isZero(AbstractExpression node){
		if(node.getFirstChildOfType(ASTConstant.class)!=null)
		{
			ASTConstant constNode = (ASTConstant)node.getFirstChildOfType(ASTConstant.class);
			if(constNode.getImage() == null)
				return false;
			if(constNode.getImage().equals("0"))		
				return true;
			else return false;
		}
		else {			
			ExpressionValueVisitor expvst = new ExpressionValueVisitor();
			ExpressionVistorData visitdata = new ExpressionVistorData();
			visitdata.currentvex = node.getCurrentVexNode();
			visitdata.currentvex.setfsmCompute(true);
			expvst.visit(node, visitdata);
			visitdata.currentvex.setfsmCompute(false);
			Expression value1 = visitdata.value;
			Domain mydomain=null;
			if(value1!=null)
			mydomain = value1.getDomain(visitdata.currentvex.getLastsymboldomainset());
			if((mydomain instanceof IntegerDomain)&&
					(((IntegerDomain)mydomain).getMin()==((IntegerDomain)mydomain).getMax())
					&& ((IntegerDomain)mydomain).getMin() == 0)
				return true;
			else return false;
		}
	}
	
}
