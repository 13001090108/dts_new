package softtest.rules.c.hw;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import softtest.ast.c.ASTIterationStatement;
import softtest.ast.c.ASTPrimaryExpression;
import softtest.ast.c.SimpleNode;
import softtest.fsm.c.FSMMachine;
import softtest.fsm.c.FSMMachineInstance;
import softtest.rules.c.StateMachineUtils;
import softtest.symboltable.c.VariableNameDeclaration;

/**
 * @author Pzq
 * <p>
 * MLV - Modify Loop Variable.<br>
 * 循环内修改循环变量.
 * </p>
 */
public class HW_6_1_MLVStateMachine {

    /**
     * <p>
     * Created MLV state machine instances for the specific function.<br>
     * It's called by reflection.
     * </p>
     * 
     * @param node
     *            the ast node of the function, it's FunctionDefinition in
     *            default, TranslationUnit when Scope="File" was used in xml
     * @param fsm
     *            the finite state machine object generated by parsing the xml
     *            fsm descriptor, it's the template of the fsm instance
     * @return the list of finite state machine instance
     */
    public static List<FSMMachineInstance> createHW_6_1_MLVStateMachines(
            SimpleNode node, FSMMachine fsm) {
        // hold the result
        List<FSMMachineInstance> list = new LinkedList<FSMMachineInstance>();
        // find all outer loop which has at least one inner loop
        String xpath = ".//IterationStatement/Expression/AssignmentExpression/RelationalExpression/UnaryExpression/PostfixExpression/PrimaryExpression[count(*)=0]";
        List<SimpleNode> evaluationResults = StateMachineUtils
                .getEvaluationResults(node, xpath);
       
        List<VariableNameDeclaration>varList=new LinkedList<VariableNameDeclaration>();
        ASTPrimaryExpression pe=null;
        for (SimpleNode snode : evaluationResults) {
        	pe = (ASTPrimaryExpression) snode;
            VariableNameDeclaration var=pe.getVariableNameDeclaration();
            if(var!=null){
            	varList.add(var);
            }
            
//            do {
//                Set<VariableNameDeclaration> result = findLoopVariable(
//                        findLoopVariableCandidate(itrNode), itrNode);
//                for (VariableNameDeclaration loopVariable : result) {
//                    if (loopVariables.containsKey(loopVariable)) {
//                        FSMMachineInstance fsminstance = fsm.creatInstance();
//                        fsminstance.setRelatedASTNode(itrNode);
//                        fsminstance.setRelatedVariable(loopVariable);
//                        fsminstance.setDesp("第"
//                                + loopVariables.get(loopVariable)
//                                        .getBeginLine() + "行的循环和第"
//                                + itrNode.getBeginLine() + "行的循环使用了相同的循环变量"
//                                + loopVariable.getImage());
//                        list.add(fsminstance);
//                    } else {
//                        loopVariables.put(loopVariable, snode);
//                    }
//                }
//                List<Node> temp = itrNode
//                        .findChildrenOfType(ASTIterationStatement.class);
//                // the first one is snode itself if there exsists
//                itrNode = temp.size() <= 1 ? null
//                        : (ASTIterationStatement) temp.get(1);
//            } while (itrNode != null);
        }
        
        String iterXpath=".//IterationStatement";
        evaluationResults = StateMachineUtils.getEvaluationResults(node, iterXpath);
        ASTIterationStatement itrNode = null;
        for (SimpleNode snode : evaluationResults) {
        	itrNode = (ASTIterationStatement) snode;
        	List<ASTPrimaryExpression>peListAdd=itrNode.findXpath(".//AssignmentExpression/UnaryExpression/PostfixExpression[@Operators='++']/PrimaryExpression");
        	List<ASTPrimaryExpression>peListSub=itrNode.findXpath(".//AssignmentExpression/UnaryExpression/PostfixExpression[@Operators='--']/PrimaryExpression");
        	Map<VariableNameDeclaration, ASTPrimaryExpression> varMap=new HashMap<VariableNameDeclaration, ASTPrimaryExpression>();
        	if(peListAdd.size()==0||peListSub.size()==0)
        	{
        		continue;
        	}
        	for(ASTPrimaryExpression pevar:peListAdd){
            VariableNameDeclaration var=pevar.getVariableNameDeclaration();
	            if(var!=null&&varList.contains(var)){
	            	varMap.put(var, pevar);
	            }
            }
        	for(ASTPrimaryExpression pevar:peListSub){
                VariableNameDeclaration var=pevar.getVariableNameDeclaration();
    	            if(var!=null&&varList.contains(var)){
    	            	addFSM(list,varMap.get(var),pevar,fsm,var);
    	            }
                }
        }
        return list;
    }





/**
 * <p>
 * Add the fsm instance to the list result.
 * </p>
 * 
 * @param list
 *            the result list
 * @param node
 *            the node related to the fsm instance
 * @param fsm
 *            the model of the fsm instance
 * @param varDecl
 *            the variable name declaration related to the fsm instance
 */
private static void addFSM(List<FSMMachineInstance> list, SimpleNode node,SimpleNode node2,
        FSMMachine fsm, VariableNameDeclaration varDecl) {
    FSMMachineInstance fsminstance = fsm.creatInstance();
    fsminstance.setRelatedASTNode(node);
    fsminstance.setRelatedVariable(varDecl);
    if(node!=null){
    fsminstance.setReleatedVexNode(node.getCurrentVexNode());
    fsminstance.setDesp("在循环体内同时出现对循环变量" + varDecl.getImage() + "在第"
            + node.getBeginLine() + "行进行加操作和第"+node2.getBeginLine()+"行进行减操作");
    list.add(fsminstance);
    }
}
}