package softtest.rules.c.hw;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.jaxen.JaxenException;

import softtest.ast.c.ASTIterationStatement;
import softtest.ast.c.ASTPrimaryExpression;
import softtest.ast.c.SimpleNode;
import softtest.cfg.c.VexNode;
import softtest.fsm.c.FSMMachine;
import softtest.fsm.c.FSMMachineInstance;
import softtest.rules.c.StateMachineUtils;
import softtest.symboltable.c.NameOccurrence;
import softtest.symboltable.c.SourceFileScope;
import softtest.symboltable.c.VariableNameDeclaration;
import softtest.symboltable.c.NameOccurrence.OccurrenceType;

/**
 * <p>
 * DAB - Direct use Argument as loop Bound.<br>
 * 外部变量直接作为循环上下界.
 * </p>
 */
public class HW_6_1_DABStateMachine {

	/**
	 * <p>
	 * Created DAB state machine instances for the specific function.<br>
	 * It's called by reflection.
	 * </p>
	 * 
	 * @param node
	 *            the ast node of the function, it's FunctionDefinition in
	 *            default, TranslationUnit when Scop="File" was used in xml
	 * @param fsm
	 *            the finite state machine object generated by parsing the xml
	 *            fsm descriptor, it's the template of the fsm instance
	 * @return the list of finite state machine instance
	 */
	public static List<FSMMachineInstance> createDABStateMachines(
			SimpleNode node, FSMMachine fsm) {
		// hold the result
		List<FSMMachineInstance> list = new LinkedList<FSMMachineInstance>();
		// find all loop
		String xpath = ".//IterationStatement";
		List<SimpleNode> evaluationResults = StateMachineUtils
				.getEvaluationResults(node, xpath);
		for (SimpleNode snode : evaluationResults) {
			ASTIterationStatement itrNode = (ASTIterationStatement) snode;
			Set<VariableNameDeclaration> boundVar = findBoundVariable(
					findBoundVariableCandidate(itrNode), itrNode);
			for (Iterator<VariableNameDeclaration> itr = boundVar.iterator(); itr
					.hasNext();) {
				addFSM(list, itrNode, fsm, itr.next());
			}
		}
		return list;
	}

	/**
	 * <p>
	 * Find bound variable candidates of a iteration.<br>
	 * The variable used in loop terminate condition can be a candidate.
	 * </p>
	 * 
	 * @param itrNode
	 *            the ast node of the iteration, it's ASTIterationStatement
	 * @return the bound variable candidates
	 */
	private static Set<VariableNameDeclaration> findBoundVariableCandidate(
			ASTIterationStatement itrNode) {
		// hold the result
		Set<VariableNameDeclaration> result = new HashSet<VariableNameDeclaration>();

		// prepare the xpath navigation for the expressions which are used as
		// loop condition
		String varXpath = "/UnaryExpression/PostfixExpression[count(*)=1]/PrimaryExpression[count(*)=0]";

		String xpathString = "/Expression//RelationalExpression" + varXpath // i>n
				+ "|/Expression/AssignmentExpression" + varXpath // i
				+ "|/Expression//LogicalANDExpression" + varXpath // a && i>0
				+ "|/Expression//LogicalORExpression" + varXpath; // a || i>0

		String loopType = itrNode.getImage();
		if (loopType.equals("for")) {
			// for
			int n = -1;
			// find the index of the second expression, -1 means it does not
			// exsit
			if (itrNode.forChild[1]) {
				if (itrNode.forChild[0]) {
					n = 2;
				} else {
					n = 1;
				}
			}
			if (n == -1) {
				// no need to process further, we consider there is no loop
				// variable
				return result;
			} else {
				// change the xpath expression
				xpathString = xpathString.replaceAll("/Expression",
						"/Expression[" + n + "]");
			}
		}
		// find candidate using xpath for three kinds of loop(while, do-while
		// and for)
		List candidateList = findChildNodesWithXPath(itrNode, xpathString);
		for (Object o : candidateList) {
			ASTPrimaryExpression varNode = (ASTPrimaryExpression) o;
			VariableNameDeclaration varDecl = varNode.getVariableDecl();
			if (varDecl != null
					&& (varDecl.isParam() || varDecl.getScope() instanceof SourceFileScope)) {
				result.add(varDecl);
			}
		}
		return result;
	}

	/**
	 * <p>
	 * Confirm the bound variable in candidates.<br>
	 * The candidate domain which does not change in the loop can be chosen.
	 * </p>
	 * 
	 * @param candidates
	 *            the loop variable candidates
	 * @param itrNode
	 *            the ast node of the iteration, it's ASTIterationStatement
	 * @return the loop variable candidates
	 */
	private static Set<VariableNameDeclaration> findBoundVariable(
			Set<VariableNameDeclaration> candidates,
			ASTIterationStatement itrNode) {
		if (candidates.size() == 1 || candidates.size() == 0) {
			// if only one candidate was found, it's the loop variable
			return candidates;
		}
		Set<VariableNameDeclaration> boundVar = new HashSet<VariableNameDeclaration>();
		// find the variable used in the statement of the loop and check if it's
		// domain changed, ### is the place holder
		String xpathString = "/Statement/CompoundStatement/StatementList/Statement/ExpressionStatement//PrimaryExpression[@Image='###']";

		// for loop should check the 3rd expression under itrNode if exists
		String forPath = null;
		if (itrNode.getImage().equals("for")) {
			forPath = "/Expression//PrimaryExpression[@Image='###']";
			if (itrNode.forChild[2]) {
				// index of 3rd expression
				int n = 3;
				if (!itrNode.forChild[0] && !itrNode.forChild[1]) {
					n = 1;
				} else if (itrNode.forChild[0] ^ itrNode.forChild[1]) {
					n = 2;
				}
				forPath = forPath.replace("/Expression", "/Expression[" + n
						+ "]");
			}
		}
		for (Iterator<VariableNameDeclaration> itr = candidates.iterator(); itr
				.hasNext();) {
			VariableNameDeclaration varDecl = itr.next();
			String xpath = xpathString.replace("###", varDecl.getImage());
			List varOcc = findChildNodesWithXPath(itrNode, xpath);
			if (forPath != null) {
				forPath = forPath.replace("###", varDecl.getImage());
				List temp = findChildNodesWithXPath(itrNode, forPath);
				varOcc.addAll(temp);
			}
			boolean changed = false;
			for (Object o : varOcc) {
				SimpleNode snode = (SimpleNode) o;
				VexNode vex = snode.getCurrentVexNode();
				// Domain domain = vex.getDomain(varDecl);
				// Domain lastDomain = getLastDomain(snode);
				// if (!domain.equals(lastDomain)) {
				// changed = true;
				// break;
				// }
				NameOccurrence occ = findOccurrence(vex, varDecl);
				if (occ == null) {
					continue;
				}
				if (occ.getOccurrenceType() == OccurrenceType.DEF_AFTER_USE
						|| occ.getOccurrenceType() == OccurrenceType.DEF) {
					changed = true;
				}
				if (changed) {
					break;
				}
			}
			// loop bound must not be changed
			if (!changed) {
				boundVar.add(varDecl);
			}
		}
		return boundVar;
	}

	/**
	 * <p>
	 * Find child Nodes with xpath, wrap the exception and return an empty list.
	 * </p>
	 * 
	 * @param node
	 *            the ast node
	 * @param xpath
	 *            the String which represents a xpath expression
	 * @return the List contains the result ast node
	 */
	private static List findChildNodesWithXPath(SimpleNode node, String xpath) {
		try {
			return node.findChildNodesWithXPath(xpath);
		} catch (JaxenException e) {
			return new ArrayList();
		}
	}

	/**
	 * <p>
	 * Add the fsm instance to the list result.
	 * </p>
	 * 
	 * @param list
	 *            the result list
	 * @param node
	 *            the node related to the fsm instance
	 * @param fsm
	 *            the model of the fsm instance
	 * @param varDecl
	 *            the variable name declaration related to the fsm instance
	 */
	private static void addFSM(List<FSMMachineInstance> list, SimpleNode node,
			FSMMachine fsm, VariableNameDeclaration varDecl) {
		FSMMachineInstance fsminstance = fsm.creatInstance();
		fsminstance.setRelatedASTNode(node);
		fsminstance.setRelatedVariable(varDecl);
		fsminstance.setReleatedVexNode(node.getCurrentVexNode());
		fsminstance.setDesp("外部变量" + varDecl.getImage() + "在第"
				+ node.getBeginLine() + "行的循环中被直接当做循环的边界使用。");
		list.add(fsminstance);
	}

	/**
	 * <p>
	 * Find the occurrence of a variable. This method should be put into
	 * VexNode.
	 * </p>
	 * 
	 * @param vex
	 *            the vex node
	 * @param varDecl
	 *            the variable name declaration
	 */
	private static NameOccurrence findOccurrence(VexNode vex,
			VariableNameDeclaration varDecl) {
		if (vex == null || varDecl == null) {
			return null;
		}
		ArrayList<NameOccurrence> occs = vex.getOccurrences();
		for (NameOccurrence occ : occs) {
			if (occ.getDeclaration() == varDecl) {
				return occ;
			}
		}
		return null;
	}
}
